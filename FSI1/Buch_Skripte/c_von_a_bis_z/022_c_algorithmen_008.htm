<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>Galileo Computing :: C von A bis Z &ndash; 22.8 Backtracking</title>
<meta name="title" content="Galileo Computing :: C von A bis Z - 22.8 Backtracking">
<meta name="author" content="J&uuml;rgen Wolf ">
<meta name="publisher" content="Galileo Press 2009">
<meta name="copyright" content="Galileo Press 2009">
<meta name="Description" content="C von A bis Z - Das umfassende Handbuch &ndash; 22.8 Backtracking">
<meta name="audience" content="Alle">
<meta name="robots" content="INDEX,FOLLOW">
<meta http-equiv="content-language" content="de">
<link rel="stylesheet" type="text/css" href="common/galileo_open.css">
<link rel="prev" href="022_c_algorithmen_007.htm">
<link rel="next" href="023_c_cgi_001.htm"><script type="text/javascript"><!--
    function OpenWin(url,name,height,width)
    {
      var InfoWin = window.open(url,name,"directories=0,height="+height+",width=" + width + ",hotkeys=0,location=0,menubar=0,resizable=1,screenX=150,screenY=10,left=150,top=10,scrollbars=1,status=1,titlebar=0,toolbar=0");
      InfoWin.focus();
    }
    //--></script><link href="common/prettify.css" type="text/css" rel="stylesheet"><script type="text/javascript" src="common/prettify.js"></script></head>
<body vlink="#000099" link="#000099" alink="#000099" onload="prettyPrint()">
<table width="100%" border="0" cellpadding="0" cellspacing="0" bgcolor="#000066">
<tr>
<td height="74" valign="bottom" colspan="2"><a href="http://www.galileocomputing.de/katalog/openbook?GPP=opc3"><img src="common/galileocomputing_openbook.gif" width="200" height="56" border="0" alt="Galileo Computing < openbook >" title="Galileo Computing < openbook >"></a></td>
<td width="80" height="74"><a href="http://www.galileocomputing.de/?GPP=opc3"><img src="common/galileocomputing.gif" border="0" alt="Galileo Computing - Professionelle Bücher. Auch für Einsteiger." title="Galileo Computing - Professionelle Bücher. Auch für Einsteiger."></a></td>
</tr>
</table>
<div align="right"><a href="http://www.galileocomputing.de/?GPP=opc3" class="navnav">Professionelle Bücher. Auch für Einsteiger.</a></div><br><table class="tbl" border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td width="190" valign="top">
<table class="tbl1" border="0" cellpadding="3" cellspacing="0" width="190" align="left">
<tr>
<td class="tbl2"><a class="nav" href="index.htm#_top">Inhaltsverzeichnis</a></td>
</tr>
<tr>
<td><a class="navnav" href="000_c_vorwort_001.htm#mj764cb3fd439d3b95d1843e7c7d17f235">Vorwort</a></td>
</tr>
<tr>
<td><a class="navnav" href="000_c_vorwort_gutachter_001.htm#mj3d41cb339c9b2fc1d6e99cdaa93c3860">Vorwort des Gutachters</a></td>
</tr>
<tr>
<td><a class="navnav" href="001_c_einstieg_in_c_001.htm#mja24d93ff97bb42dbebf4689160c45195">1 Einstieg in C</a></td>
</tr>
<tr>
<td><a class="navnav" href="002_c_das_erste_programm_001.htm#mj2604a667cc98d3fa2178751273346b91">2 Das erste Programm</a></td>
</tr>
<tr>
<td><a class="navnav" href="003_c_grundlagen_001.htm#mj7ac54ba315b94149806c1de3fc89ee7f">3 Grundlagen</a></td>
</tr>
<tr>
<td><a class="navnav" href="004_c_ein_ausgabe_001.htm#mj20c131820fbfb1497afd796ee443599e">4 Formatierte Ein-/Ausgabe mit »scanf()« und »printf()«</a></td>
</tr>
<tr>
<td><a class="navnav" href="005_c_basisdatentypen_001.htm#mjeda2957449ddc812dad62b400fe57752">5 Basisdatentypen</a></td>
</tr>
<tr>
<td><a class="navnav" href="006_c_operatoren_001.htm#mjab3693b096d581607801a36ce88905fc">6 Operatoren</a></td>
</tr>
<tr>
<td><a class="navnav" href="007_c_typumwandlung_001.htm#mj5c5e497ac2ab4367fe9df0ffd218cfca">7 Typumwandlung</a></td>
</tr>
<tr>
<td><a class="navnav" href="008_c_kontrollstrukturen_001.htm#mjc7bf6f584a2fe20b4c5f6b16ba15d57d">8 Kontrollstrukturen</a></td>
</tr>
<tr>
<td><a class="navnav" href="009_c_funktionen_001.htm#mj7893101be51aa469fe52334038acd465">9 Funktionen</a></td>
</tr>
<tr>
<td><a class="navnav" href="010_c_praeprozessor_001.htm#mjacdd200a20163a4d3fa418b6cb95763e">10 Präprozessor-Direktiven</a></td>
</tr>
<tr>
<td><a class="navnav" href="011_c_arrays_001.htm#mje29de26c54a3884f7316cbbb2a073ad8">11 Arrays</a></td>
</tr>
<tr>
<td><a class="navnav" href="012_c_zeiger_001.htm#mjee28a882ef9125d2c4cc49121b2c65c1">12 Zeiger (Pointer)</a></td>
</tr>
<tr>
<td><a class="navnav" href="013_c_kommandozeilenargumente_001.htm#mjf6a9e42fa3bc25b2b1e06270e7bf8f68">13 Kommandozeilenargumente</a></td>
</tr>
<tr>
<td><a class="navnav" href="014_c_dyn_speicherverwaltung_001.htm#mj8d062301d2449b13710f1484d499cd9b">14 Dynamische Speicherverwaltung</a></td>
</tr>
<tr>
<td><a class="navnav" href="015_c_strukturen_001.htm#mj5e146ba18168113a5c645cd2d07c4ec8">15 Strukturen</a></td>
</tr>
<tr>
<td><a class="navnav" href="016_c_ein_ausgabe_funktionen_001.htm#mj136f9ac6b5b7c440aafe5010411ef011">16 Ein-/Ausgabe-Funktionen</a></td>
</tr>
<tr>
<td><a class="navnav" href="017_c_dateien_verzeichnisse_001.htm#mj9f81aea722a9edb8d0080df81eb9402c">17 Attribute von Dateien und das Arbeiten mit Verzeichnissen (nicht ANSI C)</a></td>
</tr>
<tr>
<td><a class="navnav" href="018_c_stdarg_h_001.htm#mj9d64febdc46a1375e5c4498b17154e30">18 Arbeiten mit variabel langen Argumentlisten &#8211; &lt;stdarg.h&gt;</a></td>
</tr>
<tr>
<td><a class="navnav" href="019_c_zeitroutinen_001.htm#mj0a8102e96a1297bd767ac7274e069f0f">19 Zeitroutinen</a></td>
</tr>
<tr>
<td><a class="navnav" href="020_c_headerdateien_001.htm#mjf3caede8ebd504dc6b7454b297c251e8">20 Weitere Headerdateien und ihre Funktionen (ANSI C)</a></td>
</tr>
<tr>
<td><a class="navnav" href="021_c_dyn_datenstrukturen_001.htm#mja75ba2f4ab8f95e9e321d195c1e26d76">21 Dynamische Datenstrukturen</a></td>
</tr>
<tr>
<td><a class="navh" href="##mj07afe6f332eab2e8168da2f69f7b31c4">22 Algorithmen</a></td>
</tr>
<tr>
<td><a class="navnav" href="023_c_cgi_001.htm#mj6c4219b4e615fa24deaa57d5c3d04db8">23 CGI mit C</a></td>
</tr>
<tr>
<td><a class="navnav" href="024_c_mysql_001.htm#mj12dab301033f9fd856aa739270c45e08">24 MySQL und C</a></td>
</tr>
<tr>
<td><a class="navnav" href="025_c_netzwerkprogrammierung_001.htm#mja8101c6e0e4cb2e6fd8312114dad30d7">25 Netzwerkprogrammierung und Cross&ndash;Plattform-Entwicklung</a></td>
</tr>
<tr>
<td><a class="navnav" href="026_c_paralleles_rechnen_001.htm#mj710dc0ad851d57e60533f8797ff9c1e6">26 Paralleles Rechnen</a></td>
</tr>
<tr>
<td><a class="navnav" href="027_c_sicheres_programmieren_001.htm#mj13eba8f9d68ac8414bffaa3a1b24ec31">27 Sicheres Programmieren</a></td>
</tr>
<tr>
<td><a class="navnav" href="028_c_weiterfuehrendes_001.htm#mj3e65f750149ade087925f303b3871af9">28 Wie geht&#8217;s jetzt weiter?</a></td>
</tr>
<tr>
<td><a class="navnav" href="029_c_anhang_a_001.htm#mjec9bf1c5e3fe2e46047c2f9c7aa9c531">A Operatoren</a></td>
</tr>
<tr>
<td><a class="navnav" href="030_c_anhang_b_001.htm#mj803443bb6e7546011c48e6e57fbdbb64">B Die C-Standard-Bibliothek</a></td>
</tr>
<tr>
<td><a class="navnav" href="stichwort.htm#_top">Stichwort</a></td>
</tr>
<tr>
<td><br><a href="http://download.galileo-press.de/openbook/c_von_a_bis_z/galileocomputing_c_von_a_bis_z.zip" class="navnav"><strong>Download:</strong><br>- ZIP, ca. 10,6 MB</a></td>
</tr>
<tr>
<td><a href="http://www.galileocomputing.de/2132?GPP=opc3" class="navnav">Buch bestellen</a></td>
</tr>
<tr>
<td><a class="navnav" href="#kommentar">Ihre Meinung?</a><br><br></td>
</tr>
</table>
</td>
<td width="10"><img src="common/spacer10.gif" width="10" height="10" alt="Spacer"></td>
<td width="85%" valign="top" align="center"><div align="center">
<table width="98%" border="0" cellspacing="0" cellpadding="0" bgcolor="#FFFFFF">
<tr>
<td width="100%" class="start" colspan="1" height="22" align="center"><table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="25%"><a href="022_c_algorithmen_007.htm" class="navnav"> &lt;&lt;   zurück</a></td>
<td width="49%"><div align="center"><a href="http://www.galileocomputing.de/?GPP=opc3" class="navnav">Galileo Computing</a> / <a href="http://www.galileocomputing.de/katalog/openbook/?GPP=opc3" class="navnav">&lt;openbook&gt;</a> / <a href="index.htm" class="navnav"> C von A bis Z</a></div></td>
<td align="right" width="25%"><div align="right"><a href="023_c_cgi_001.htm" class="navnav">vor   &gt;&gt; </a></div></td>
</tr>
</table></td>
</tr>
<tr>
<td width="100%" valign="top"><table width="100%" border="0" cellpadding="10" cellspacing="0" class="box">
<tr>
<td colspan="2"><a href="http://www.galileocomputing.de/2132?GPP=opc3" class="buchtitel">C von A bis Z</a><span class="autor"> von J&uuml;rgen Wolf </span><br><span class="untertitel">Das umfassende Handbuch</span></td>
</tr>
<tr>
<td valign="top" width="211"><dl>
<dt><a href="http://www.galileocomputing.de/2132?GPP=opc3" class="navnav"><img src="common/9783836214117.gif" border="0" alt="Buch: C von A bis Z" title="Buch: C von A bis Z"></a></dt>
<dd><br><a href="http://www.galileocomputing.de/2132?GPP=opc3"><span class="autor"><strong>C von A bis Z</strong><br>3., aktualisierte und erweiterte Auflage, geb., mit CD und Referenzkarte<br>1.190 S., 39,90 Euro<br>Galileo Computing<br>ISBN 978-3-8362-1411-7</span></a></dd>
</dl></td>
<td width="80%"><table border="0">
<tr>
<td valign="baseline"><img src="common/pfeil_u.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="3" class="kap"><strong><a href="022_c_algorithmen_001.htm#mj07afe6f332eab2e8168da2f69f7b31c4" class="navnav">22 Algorithmen</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="022_c_algorithmen_001.htm#mjad955691d6bbeab76c26bebeb46bfb5b" class="navnav">22.1 Was sind Algorithmen?</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="022_c_algorithmen_002.htm#mjdd65482f3fdbcd022155b3035e6f070c" class="navnav">22.2 Wie setze ich Algorithmen ein?</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="022_c_algorithmen_003.htm#mja4d6cf19b9113d221e26e0a19eb4148c" class="navnav">22.3 Sortieralgorithmen</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="022_c_algorithmen_003.htm#mj1fdda2148808601a86a54a7701775bec" class="navnav">22.3.1 »Selection Sort« &#8211; sortieren durch Auswählen</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="022_c_algorithmen_003.htm#mj925248949647af9ef7f16d215f433a8c" class="navnav">22.3.2 Insertion Sort</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="022_c_algorithmen_003.htm#mje2d240f1f56f6186232f65773fc37070" class="navnav">22.3.3 Bubble Sort</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="022_c_algorithmen_003.htm#mj62f350471ff0f91a8910f6d0e6c5cf18" class="navnav">22.3.4 Shellsort</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="022_c_algorithmen_003.htm#mj035bded10a26be556df779f234784e89" class="navnav">22.3.5 Quicksort</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="022_c_algorithmen_003.htm#mjde22312f4b61457b2efb0f9f17a7b269" class="navnav">22.3.6 qsort()</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="022_c_algorithmen_003.htm#mje59f09c2df1dfa3ec926ae230eb00d31" class="navnav">22.3.7 Zusammenfassung der Sortieralgorithmen</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="022_c_algorithmen_004.htm#mje1108bedaa52e56c3a2231952efc760d" class="navnav">22.4 Suchalgorithmen &#8211; Grundlage zur Suche</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="022_c_algorithmen_004.htm#mjd215dedb31c115ea3fc6aa2a9f3b3377" class="navnav">22.4.1 Lineare Suche</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="022_c_algorithmen_004.htm#mjc74f9bee71009b607d837f401fab37e1" class="navnav">22.4.2 Binäre Suche</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="022_c_algorithmen_004.htm#mj50e751f674a269097a8f867476f4e6ab" class="navnav">22.4.3 Binäre (Such-)Bäume</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="022_c_algorithmen_004.htm#mj8a624d55f599e29effaab0089aa75a28" class="navnav">22.4.4 Elemente im binären Baum einordnen</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="022_c_algorithmen_004.htm#mj0a5e3b9745ce4405d8764546050bed3b" class="navnav">22.4.5 Binäre Bäume traversieren</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="022_c_algorithmen_004.htm#mj4288fdcfb29e6adbcbf80c102c324f2f" class="navnav">22.4.6 Löschen eines Elements im binären Baum</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="022_c_algorithmen_004.htm#mjfe709ec1d375f55e7805e53ce79c7880" class="navnav">22.4.7 Ein binärer Suchbaum in der Praxis</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="022_c_algorithmen_004.htm#mjc0eebbc48d257496d83af8b5bcf3c5b9" class="navnav">22.4.8 Binäre Suchbäume mit Eltern-Zeiger und Threads</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="022_c_algorithmen_004.htm#mj86c6493733dadbfb1f7710f0a687b1ef" class="navnav">22.4.9 Ausgeglichene Binärbäume</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="022_c_algorithmen_004.htm#mjc53ab8c9ed2dac1cd824c4d3f972f754" class="navnav">22.4.10 Algorithmen für ausgeglichene Bäume &#8211; eine Übersicht</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="022_c_algorithmen_005.htm#mj0a40e081a9df138f149a2f446fb499fd" class="navnav">22.5 Hashing (Zerhacken)</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="022_c_algorithmen_005.htm#mjbd1d8614064df7a2d1f74b2322070197" class="navnav">22.5.1 Wann wird Hashing verwendet?</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="022_c_algorithmen_005.htm#mj6b2e95378544d9975a8312b6bb884a8f" class="navnav">22.5.2 Was ist für das Hashing erforderlich?</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="022_c_algorithmen_005.htm#mjffda6918d10dabde4c2d29ebb835e371" class="navnav">22.5.3 Hash-Funktion</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="022_c_algorithmen_005.htm#mj19e26fc27715d5ff46edac5940f4d5ff" class="navnav">22.5.4 Hashing mit direkter Adressierung</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="022_c_algorithmen_005.htm#mjf182065dfeada5efe09d22e63762605f" class="navnav">22.5.5 Vergleich von Hashing mit binären Bäumen</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="022_c_algorithmen_006.htm#mj73dd4e072f6667a0f887c5a613a4691d" class="navnav">22.6 String-Matching</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="022_c_algorithmen_006.htm#mjf7d6e5fb93d300365b9df366326bcc13" class="navnav">22.6.1 Brute-Force-Algorithmus</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="022_c_algorithmen_006.htm#mjaaad91c95f148185e8ca3b36d2f7a8ca" class="navnav">22.6.2 Der Algorithmus von Knuth/Morris/Pratt (KMP)</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="022_c_algorithmen_006.htm#mj6e6634183f974a372635540c36053fdb" class="navnav">22.6.3 Weitere String-Matching-Algorithmen</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="022_c_algorithmen_007.htm#mjf4e645bb4920a03ebda8385b7b013724" class="navnav">22.7 Pattern Matching (reguläre Ausdrücke)</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="#mj949af93bc0dacf07baf688227fc46cbf" class="navh">22.8 Backtracking</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mj3bad29bcf42f5c904880c75110704913" class="navh">22.8.1 Der Weg durch den Irrgarten</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mjdf73b2552404835ed8da47e6fc60f70c" class="navh">22.8.2 Das 8-Dame-Problem</a></strong></td>
</tr>
</table><br></td>
</tr>
</table>
<table width="100%" cellpadding="20" cellspacing="0" border="0" bgcolor="#eeeeee">
<tr>
<td><div class="main"><a id="mj949af93bc0dacf07baf688227fc46cbf" name="mj949af93bc0dacf07baf688227fc46cbf"></a><a name="t21"></a><a name="t2t31"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div>
<h2 class="t2"><span class="cfett">22.8</span><span class="cfett"> Backtracking</span>  <a href="#t2t32"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><img src="common/15x15leer.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></h2>
<p>Backtracking ist ein Verfahren, das nach dem Trial-and-Error-Prinzip (Versuch und Irrtum) ausgeführt wird. Damit wird versucht, aus Teillösungen systematisch zu einer Komplettlösung zu kommen. Steht man beispielsweise bei einer Teillösung vor einer Sackgasse, werden einzelne bzw. mehrere Schritte wieder rückgängig gemacht. Gerät man wieder in eine Sackgasse, werden eben nochmals entsprechend viele Schritte zurück gemacht. Dieser Vorgang wird so lange wiederholt, bis man zu einer Lösung des Problems kommt oder feststellen muss, dass es zu diesem Problem keine Lösung gibt.</p><a id="mj3bad29bcf42f5c904880c75110704913" name="mj3bad29bcf42f5c904880c75110704913"></a><a name="t31"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t32"></a><h3 class="t3"><span class="cfett">22.8.1</span><span class="cfett"> Der Weg durch den Irrgarten</span>  <a href="#t2t33"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t31"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Das Prinzip soll anhand eines simplen Beispiels demonstriert werden. Wir erstellen ein Spielfeld mit Hindernissen (»<span class="clisting">*</span>«). An der einen Ecke des Spielfeldes befindet sich »Mister C«, der Hunger hat. Auf der anderen Ecke befindet sich etwas zum Essen (»o«). Sie sollen nun mittels Backtracking Mister »C« über die Hindernisse »*« zum Essen »o« führen. Das Ganze sieht folgendermaßen aus:</p>
<div class="listing"><pre class="prettyprint">#################################################
#<span class="cfett">C</span> *                                            #
#  *                    *                       #
#                                               #
#     *        *   *                        *   #
#            *         *                        #
# *        *   *                 *              #
#                                               #
#   *   *    *       *             *            #
# *                                             #
#           * *                      *          #
#                  *                      *  *  #
#        *       *        *                   <span class="cfett"> o</span>#
#################################################</pre></div>
<p>Das Spielfeld soll mit einem zweidimensionalen <span class="clisting">char</span>-Array mit 15 Zeilen und 50 Spalten dargestellt werden:</p>
<div class="listing"><pre class="prettyprint">// 15 Zeilen; 50 Spalten
char spielfeld[15][50];</pre></div>
<p>Mister C selbst soll sich erst mal in vier verschiedene Richtungen bewegen können:</p>
<div class="bildbox">
<p><a name="IDA1HUQ"></a><a onClick="OpenWin('bilder/22_037.gif','Abbildung',800,800)"><img border="0" src="bilderklein/klein22_037.gif" alt="Abbildung"><br><span class="tabunter">Hier klicken, um das Bild zu vergrößern</span></a></p>
</div>
<p class="tabunter"><strong>Abbildung 22.37    </strong>Koordinatensystem für Mister C</p>
<p>Somit benötigen Sie vier verschiedene Funktionsaufrufe: jeweils einen für die Richtung <span class="clisting">+x</span> (eine Zeile nach unten), <span class="clisting">-x</span> (eine Zeile nach oben), <span class="clisting">+y</span> (eine Spalte nach rechts) und <span class="clisting">-y</span> (eine Spalte nach links). In der Praxis sehen diese Aufrufe folgendermaßen aus:</p>
<div class="listing"><pre class="prettyprint">step(x, y+1);
step(x+1, y);
step(x-1, y);
step(x, y-1);</pre></div>
<p>Natürlich handelt es sich hierbei um Funktionsselbstaufrufe (Rekursionen). Für die optische Darstellung (Ausgabe des Spielfeldes) sollten Sie hierbei auch noch die alten Positionen von <span class="clisting">x</span> und <span class="clisting">y</span> als Argumente bzw. Parameter verwenden:</p>
<div class="listing"><pre class="prettyprint">step(x, y+1, xalt=x, yalt=y);
step(x+1, y, xalt=x, yalt=y);
step(x-1, y, xalt=x, yalt=y);
step(x, y-1, xalt=x, yalt=y);</pre></div>
<p>Als Nächstes müssen Sie bestimmen, in welche Richtung Mister C zuerst gehen soll. Im zweidimensionalen Array gesehen, befindet sich Mister C an Position <span class="clisting">[1][1]</span> und das Essen an Position <span class="clisting">[13][48]</span>. Somit können Sie selbst entscheiden, ob Sie zuerst nach rechts (<span class="clisting">y+1</span>) oder nach unten (<span class="clisting">x+1</span>) gehen wollen. Im Beispiel wurde die »Verstärkt-nach-rechts-gehen«-Strategie verwendet.</p>
<p>Bevor wir Mister C also nach rechts schicken (<span class="clisting">y+1</span>), müssen Sie zuerst überprüfen, ob sich in dieser Richtung ein Hindernis (»*«) befindet und ob Sie diese Spalte nicht schon einen Funktionsaufruf zuvor besucht haben (<span class="clisting">yalt!=y+1</span>). Sind diese beiden Bedingungen erfüllt, können Sie den ersten rekursiven Funktionsaufruf starten (<span class="clisting">step(x,y+1,x,y)</span>).</p>
<p>Entscheidend für das Backtracking ist nun der Rückgabewert des rekursiven Funktionsaufrufes. Wird 1 zurückgegeben, wird der eben aufgerufene Zug ausgeführt. Hier ist der eben beschriebene Weg »nach rechts«:</p>
<div class="listing"><pre class="prettyprint">if( y+1&lt;49 &amp;&amp; spielfeld[x][y+1] !='*' &amp;&amp;
    yalt!=y+1 &amp;&amp; step(x,y+1,x,y) )
   return 1;</pre></div>
<p>Die nächsten drei Funktionsaufrufe mitsamt den Überprüfungen sehen recht ähnlich aus, nur dass diese eben für eine andere Richtung bestimmt sind:</p>
<div class="listing"><pre class="prettyprint">else if( x+1&lt;14 &amp;&amp; spielfeld[x+1][y] !='*' &amp;&amp;
         xalt!=x+1 &amp;&amp; step(x+1,y,x,y))
   return 1;

else if( x-1&gt;0 &amp;&amp; spielfeld[x-1][y] !='*' &amp;&amp;
         xalt!=x-1 &amp;&amp; step(x-1,y,x,y) )
   return 1;

else if( y-1&gt;0 &amp;&amp; spielfeld[x][y-1] !='*' &amp;&amp;
         yalt!=y-1 &amp;&amp; step(x,y-1,x,y) )
   return 1;</pre></div>
<p>Falls keiner dieser vier Aufrufe erfolgreich war, wird an den vorangegangenen Funktionsaufruf der Wert 0 (<span class="clisting">return 0</span>) zurückgegeben, womit eben dieser Zug nicht ausgeführt wird.</p>
<p>Die Abbruchbedingung ist erreicht, wenn sich Mister C an der Position des Essens (»o«) befindet. »Abgebrochen« wird aber auch, wenn das Labyrinth zu komplex ist und unser Mister C partout nicht ans Ziel finden will oder er in einer Sackgasse feststeckt, aus der es kein Zurück mehr gibt. Leider bedeutet dieser Abbruch auch einen Stack-Überlauf. Hierzu die komplette Funktion <span class="clisting">step()</span>:</p>
<div class="listing"><pre class="prettyprint">int step(int x, int y, int xalt, int yalt) {
   printf("&lt;ENTER&gt;");  getchar();
   if(spielfeld[x][y] == 'O') { /* Sind wir am Ziel? */
      spielfeld[x][y] = 'C';
      spielfeld[xalt][yalt] = ' ';
      showspielfeld();
      printf("Mister C ist zu Hause!\n");
      exit (EXIT_SUCCESS);
   }
   else if(spielfeld[x][y] == ' ') {
      spielfeld[x][y] = 'C';
      spielfeld[xalt][yalt] = ' ';
      showspielfeld();
      // ... nach rechts
      if( y+1&lt;49 &amp;&amp; spielfeld[x][y+1] !='*' &amp;&amp;
          yalt!=y+1 &amp;&amp; step(x,y+1,x,y) )
         return 1;
      // ... nach unten
      else if( x+1&lt;14 &amp;&amp; spielfeld[x+1][y] !='*' &amp;&amp;
               xalt!=x+1 &amp;&amp; step(x+1,y,x,y) )
         return 1;
      // ... nach oben
      else if( x-1&gt;0 &amp;&amp; spielfeld[x-1][y] !='*' &amp;&amp;
               xalt!=x-1 &amp;&amp; step(x-1,y,x,y) )
         return 1;
      // ... nach links
      else if( y-1&gt;0 &amp;&amp; spielfeld[x][y-1] !='*' &amp;&amp;
               yalt!=y-1 &amp;&amp; step(x,y-1,x,y) )
         return 1;
   }
 return 0;
}</pre></div>
<p>Zum besseren Verständnis sollen hier ein paar Durchläufe gemacht werden. Aufgerufen wird die Funktion in <span class="clisting">main()</span> mit:</p>
<div class="listing"><pre class="prettyprint">step(1,1,1,1);</pre></div>
<p>Somit sieht es auf dem Spielfeld beispielsweise wie folgt aus:</p>
<div class="listing"><pre class="prettyprint">#####################
#<span class="cfett">C</span>  *
#        *      *
#  *       *       *
#*    *         *</pre></div>
<p>Mister C befindet sich an Position <span class="clisting">[1][1]</span> im Spielfeld. Zuerst wird in der Funktion <span class="clisting">step()</span> überprüft, ob er bereits sein Ziel erreicht hat (was im Moment nicht der Fall ist):</p>
<div class="listing"><pre class="prettyprint">if(spielfeld[x][y] == 'O')</pre></div>
<p>Als Nächstes müssen Sie überprüfen, ob die Position <span class="clisting">[1][1]</span> überhaupt frei ist:</p>
<div class="listing"><pre class="prettyprint">else if(spielfeld[x][y] == ' ' )</pre></div>
<p>Ist diese Position frei, dann kann Mister C dort hingesetzt werden, und es sieht wie in der eben gezeigten Position aus. Jetzt wird überprüft, in welche Richtung Mister C gehen kann:</p>
<div class="listing"><pre class="prettyprint">// ... nach rechts
if( y+1&lt;49 &amp;&amp; spielfeld[x][y+1] !='*' &amp;&amp;
    yalt!=y+1 &amp;&amp; step(x,y+1,x,y) )</pre></div>
<p>Im Beispiel ist die Richtung <span class="clisting">y+1</span> frei und wurde zuvor auch nicht besucht. Somit befindet sich auf dem Stack nun folgender Funktionsaufruf:</p>
<div class="listing"><pre class="prettyprint">step(1, 1+1, 1, 1)</pre></div>
<p>Um ausgeführt zu werden, benötigt dieser Funktionsaufruf ja den Rückgabewert 1. Gehen wir mal ein paar Schritte nach vorn, wo Mister C zum ersten Mal auf ein Hindernis prallt. Folgende Funktionsaufrufe wurden bis dahin getätigt (auf dem Stack von oben nach unten):</p>
<div class="listing"><pre class="prettyprint">step(1,3+1,1,1)
step(1,2+1,1,1)
step(1,1+1,1,1)</pre></div>
<p>Nun sieht das Ganze bildlich folgendermaßen aus:</p>
<div class="listing"><pre class="prettyprint">#####################
# <span class="cfett"> C</span>*
#        *      *
#  *       *       *
#*    *         *</pre></div>
<p>Hier kommt zum ersten Mal nicht mehr die erste <span class="clisting">if</span>-Anweisung zum Zuge, da <span class="clisting">spielfeld[x+1][y] != '*'</span> nicht mehr zutrifft. Die nächste Überprüfung sieht so aus:</p>
<div class="listing"><pre class="prettyprint">// ... nach unten
else if( x+1&lt;14 &amp;&amp; spielfeld[x+1][y] != '*' &amp;&amp;
         xalt != x+1 &amp;&amp; step(x+1,y,x,y) )</pre></div>
<p>Hier scheint es wieder weiterzugehen. Somit wird als Nächstes eine Zeile nach unten gesprungen, womit sich Mister C an Position <span class="clisting">[2][3]</span> befindet:</p>
<div class="listing"><pre class="prettyprint">#####################
#   *
#<span class="cfett"> C</span>      *      *
#  *       *       *
#*    *         *</pre></div>
<p>Sie können das Beispiel gern noch ein paar Schritte weiter durchgehen. Mit dem folgenden Beispiel können Sie den Weg von Mister C im echten Leben betrachten:</p>
<div class="listing"><pre class="prettyprint">/* mister_c1.c */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;
#ifdef __unix__
   #define clrscr() printf("\x1B[2J")
#elif __BORLANDC__ &amp;&amp; __MSDOS__
   #include &lt;conio.h&gt;
#elif __WIN32__ || _MSC_VER
#define clrscr() system("cls")
#else
   #define clrscr() printf("clrscr() - Fehler!!\n")
#endif

#define HINDERNISSE 100

char spielfeld[15][50];

void createspielfeld(void) {
   int i, j, x, y;
   for(i=0, j=0; j &lt; 50; j++)
      spielfeld[i][j] = '#';

   for(i=1 ;i &lt; 15; i++)
      for(j=0;j&lt;50;j++) {
         if(j==0 || j==49)
            spielfeld[i][j] = '#';
         else
            spielfeld[i][j] = ' ';
         if(i==13 &amp;&amp; j==48)
            spielfeld[i][j] = 'O';
      }
      for(i=14,j=0;j&lt;50;j++)
         spielfeld[i][j] = '#';

      for(i=0;i&lt;=HINDERNISSE;i++) {
         x=rand()%14;
         y=rand()%48;
         if(x&lt;15&amp;&amp;y&lt;50 &amp;&amp; x&gt;0&amp;&amp;y&gt;0)
            spielfeld[x][y] = '*';

      }
   spielfeld[1][1]=' ';
}

void showspielfeld(void) {
   int i, j;
   clrscr();
   for(i=0; i &lt; 15; i++)
      for(j=0;j&lt;50;j++) {
         printf("%c",spielfeld[i][j]);
         if(j==49)
            printf("\n");
      }
}

int step(int x, int y, int xalt, int yalt) {
   printf("&lt;ENTER&gt;");  getchar();
   if(spielfeld[x][y] == 'O') { /* Sind wir am Ziel? */
      spielfeld[x][y] = 'C';
      spielfeld[xalt][yalt] = ' ';
      showspielfeld();
      printf("Mister C ist zu Hause!\n");
      exit (EXIT_SUCCESS);
   }
   else if(spielfeld[x][y] == ' ') {
      spielfeld[x][y] = 'C';
      spielfeld[xalt][yalt] = ' ';
      showspielfeld();
      /* ... nach rechts */
      if( y+1&lt;49 &amp;&amp; spielfeld[x][y+1] !='*' &amp;&amp;
          yalt!=y+1 &amp;&amp; step(x,y+1,x,y) )
         return 1;
      /* ... nach unten */
      else if( x+1&lt;14 &amp;&amp; spielfeld[x+1][y] !='*' &amp;&amp;
               xalt!=x+1 &amp;&amp; step(x+1,y,x,y) )
         return 1;
      /* ... nach oben */
      else if( x-1&gt;0 &amp;&amp; spielfeld[x-1][y] !='*' &amp;&amp;
               xalt!=x-1 &amp;&amp; step(x-1,y,x,y) )
         return 1;
      /* ... nach links */
      else if( y-1&gt;0 &amp;&amp; spielfeld[x][y-1] !='*' &amp;&amp;
               yalt!=y-1 &amp;&amp; step(x,y-1,x,y) )
         return 1;
   }
 return 0;
}


int main(void) {
   createspielfeld();
   step(1,1,1,1);
   return EXIT_SUCCESS;
}</pre></div>
<p>Das Programm bei der Ausführung:</p>
<div class="bildbox">
<p><a name="IDA52UQ"></a><a onClick="OpenWin('bilder/22_038.gif','Abbildung',800,800)"><img border="0" src="bilderklein/klein22_038.gif" alt="Abbildung"><br><span class="tabunter">Hier klicken, um das Bild zu vergrößern</span></a></p>
</div>
<p class="tabunter"><strong>Abbildung 22.38    </strong>Mister C auf der Suche  nach dem Essen</p>
<p>Dieser Code ist sehr stark auf Rechtsdrang ausgerichtet. Befindet sich Mister C an einer anderen Position, müssen Sie eben das Backtracking den Umständen anpassen.</p>
<p>Wenn Sie im Beispiel die Anzahl der Hindernisse erhöhen, werden Sie merken, dass Mister C irgendwann keinen Ausweg mehr findet, obwohl es rein theoretisch noch welche gibt &#8211; sprich, Mister C dreht sich im Kreise. Um dieses Problem zu umgehen, können Sie entweder den Quellcode noch etwas verkomplizieren oder Sie statten Mister C mit weiteren Fähigkeiten aus. Hierfür würde sich beispielsweise eignen, dass sich Mister C auch in die diagonalen Richtungen bewegen kann.</p>
<div class="bildbox">
<p><a name="IDAF3UQ"></a><a onClick="OpenWin('bilder/22_039.gif','Abbildung',800,800)"><img border="0" src="bilderklein/klein22_039.gif" alt="Abbildung"><br><span class="tabunter">Hier klicken, um das Bild zu vergrößern</span></a></p>
</div>
<p class="tabunter"><strong>Abbildung 22.39    </strong>Mehr Bewegungsfreiheit für Mister C</p>
<p>Somit hätten Sie jetzt folgende vier neue Bewegungen, die Sie in den Code einbauen müssten:</p>
<div class="listing"><pre class="prettyprint">rechtshoch(x-1,y+1)
rechtsrunter(x+1,y+1)
linksrunter(x+1,y-1)
linkshoch(x-1,y-1)</pre></div>
<p>Als Nächstes gilt es auch hier wieder festzulegen, in welcher Reihenfolge diese (jetzt acht) Bewegungen überprüft und ausgeführt werden sollen, um ans Ziel zu kommen. Da sich das Ziel rechts unten befindet, sollten Sie auch wieder diese Richtung als erste Priorität benutzen. Hierfür schlage ich folgenden Weg vor:</p>
<div class="listing"><pre class="prettyprint">if(rechts=frei)
else if(rechtsrunter=frei)
else if(rechtsoben=frei)
else if(nachunten=frei)
else if(linksrunter=frei)
else if(oben=frei)
else if(links=frei)
else if(linksoben=frei)
else return 0</pre></div>
<p>Umgeschrieben auf die Funktion <span class="clisting">step()</span> sieht dies wie folgt aus:</p>
<div class="listing"><pre class="prettyprint">int step(int x, int y, int xalt, int yalt) {
   printf("&lt;ENTER&gt;");
   getchar();

   if(spielfeld[x][y] == 'O') { /* Sind wir am Ziel? */
      spielfeld[x][y] = 'C';
      spielfeld[xalt][yalt] = ' ';
      showspielfeld();
      printf("Mister 'C' ist zu Hause!\n");
      exit (EXIT_SUCCESS);
   }
   else if(spielfeld[x][y]==' ') {
      spielfeld[x][y]='C';
      spielfeld[xalt][yalt]=' ';
      showspielfeld();
      /* rechts */
      if( y+1&lt;49 &amp;&amp; spielfeld[x][y+1] != '*'
          &amp;&amp; yalt!=y+1 &amp;&amp; step(x,y+1,x,y) )
         return 1;
      /* rechts unten */
      else if( y+1&lt;49 &amp;&amp; x+1&lt;14 &amp;&amp; spielfeld[x+1][y+1] !='*'
               &amp;&amp; xalt!=x+1 &amp;&amp; yalt!=y+1 &amp;&amp; step(x+1,y+1,x,y) )
         return 1;
      /*rechts oben*/
      else if( x-1&gt;0 &amp;&amp; y+1&lt;49 &amp;&amp; spielfeld[x-1][y+1]!='*'
               &amp;&amp; xalt!=x-1 &amp;&amp; yalt!=y+1 &amp;&amp; step(x-1,y+1,x,y))
         return 1;
      /* nach unten */
      else if( x+1&lt;14 &amp;&amp; spielfeld[x+1][y] !='*'
               &amp;&amp; xalt!=x+1 &amp;&amp; step(x+1,y,x,y) )
         return 1;
      /* links runter */
      else if(x+1&lt;14 &amp;&amp; y-1&gt;0 &amp;&amp; spielfeld[x+1][y-1]!='*'
           &amp;&amp; xalt!=x+1 &amp;&amp; yalt!=y-1 &amp;&amp; step(x+1,y-1,x,y))
         return 1;
      /* nach oben */
      else if( x-1&gt;0 &amp;&amp; spielfeld[x-1][y] !='*'
               &amp;&amp; xalt!=x-1 &amp;&amp; step(x-1,y,x,y))
         return 1;
      /* nach links */
      else if( y-1&gt;0 &amp;&amp; spielfeld[x][y-1] !='*'
               &amp;&amp; yalt!=y-1 &amp;&amp; step(x,y-1,x,y))
         return 1;
      /* links oben */
      else if( x-1&gt;0 &amp;&amp; y-1&gt;0 &amp;&amp; spielfeld[x-1][y-1] !='*'
              &amp;&amp; xalt!=x-1 &amp;&amp; yalt!=y-1 &amp;&amp; step(x-1,y-1,x,y))
         return 1;
  }
  spielfeld[x][y] = ' ';
 return 0;
}</pre></div>
<p>Wenn Sie diese Funktion in das vorige Beispiel einbauen, werden Sie merken, dass Mister C es nun schon mit mehreren Hindernissen aufnehmen kann. Aber ab einer gewissen Anzahl von Hindernissen scheitert Mister C auch hier wieder &#8211; und dies, obwohl wir noch nicht in eine Sackgasse gekommen sind.</p>
<p>Also benötigen Sie noch eine Funktion, die sich merkt, ob ein Feld bereits besucht wurde oder nicht. Dies stellt sich als einfaches Unterfangen dar, indem man einfach ein weiteres zweidimensionales Array verwendet:</p>
<div class="listing"><pre class="prettyprint">int besucht[15][50];</pre></div>
<p>Alle Felder werden erst einmal mit dem Wert 0 initialisiert. Im Programmverlauf müssen Sie anschließend nur noch die Position, die bereits besucht wurde, mit dem Wert 1 versehen. Allerdings bedeutet dies auch, dass Sie in jeder Richtung eine weitere Bedingung in der Funktion <span class="clisting">step()</span> überprüfen müssen.</p>
<p>Hier sehen Sie den kompletten Quellcode mit einem »intelligenten« Mister C:</p>
<div class="listing"><pre class="prettyprint">/* mister_c2.c */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;
#ifdef __unix__
   #define clrscr() printf("\x1B[2J")
#elif __BORLANDC__ &amp;&amp; __MSDOS__
   #include &lt;conio.h&gt;
#elif __WIN32__ || _MSC_VER
#define clrscr() system("cls")
#else
   #define clrscr() printf("clrscr() - Fehler!!\n")
#endif

#define HINDERNISSE 200

char spielfeld[15][50];
/* 1=besucht,0=nicht besucht */
int besucht[15][50];

void createspielfeld(void) {
   int i, j, x, y;
   for(i=0, j=0; j &lt; 50; j++)
      spielfeld[i][j] = '#';

   for(i=1 ;i &lt; 15; i++)
      for(j=0;j&lt;50;j++) {
         if(j==0 || j==49)
            spielfeld[i][j] = '#';
         else
            spielfeld[i][j] = ' ';
         if(i==13 &amp;&amp; j==48)
            spielfeld[i][j] = 'O';
      }
      for(i=14,j=0;j&lt;50;j++)
         spielfeld[i][j] = '#';

      for(i=0;i&lt;=HINDERNISSE;i++) {
         x=rand()%14;
         y=rand()%48;
         if(x&lt;15&amp;&amp;y&lt;50 &amp;&amp; x&gt;0&amp;&amp;y&gt;0)
            spielfeld[x][y] = '*';

      }
   spielfeld[1][1] = ' ';

   for(i=0; i&lt;15; i++)
      for(j=0; j&lt;50; j++)
     besucht[i][j] = 0;
}

void showspielfeld(void) {
   int i, j;
   clrscr();
   for(i=0; i &lt; 15; i++)
      for(j=0;j&lt;50;j++) {
         printf("%c",spielfeld[i][j]);
         if(j==49)
            printf("\n");
      }
}

int step(int x, int y, int xalt, int yalt) {
   printf("&lt;ENTER&gt;");
   getchar();

   if(spielfeld[x][y] == 'O') { /* Sind wir am Ziel? */
      spielfeld[x][y] = 'C';
      spielfeld[xalt][yalt] = ' ';
      showspielfeld();
      printf("Mister 'C' ist zu Hause!\n");
      exit (EXIT_SUCCESS);
   }
   else if(spielfeld[x][y] == ' ') {
      besucht[x][y] = 1;
      spielfeld[x][y]='C';
      spielfeld[xalt][yalt]=' ';
      showspielfeld();
      /* rechts */
      if( y+1&lt;49 &amp;&amp; spielfeld[x][y+1] !='*' &amp;&amp;
          yalt!=y+1 &amp;&amp;besucht[x][y+1]!=1 &amp;&amp;
          step(x,y+1,x,y))
         return 1;
      /* rechts unten */
      else if( y+1&lt;49 &amp;&amp; x+1&lt;14 &amp;&amp; spielfeld[x+1][y+1] !='*'
               &amp;&amp; xalt!=x+1 &amp;&amp; yalt!=y+1 &amp;&amp; besucht[x+1][y+1]!=1
               &amp;&amp; step(x+1,y+1,x,y))
         return 1;
      /* rechts oben */
      else if( x-1&gt;0 &amp;&amp; y+1&lt;49 &amp;&amp; spielfeld[x-1][y+1]!='*'
              &amp;&amp; xalt!=x-1 &amp;&amp; yalt!=y+1 &amp;&amp; besucht[x-1][y+1]!=1
              &amp;&amp; step(x-1,y+1,x,y) )
         return 1;
      /* nach unten */
      else if( x+1&lt;14 &amp;&amp; spielfeld[x+1][y] !='*'
               &amp;&amp; xalt!=x+1 &amp;&amp; besucht[x+1][y]!=1
               &amp;&amp; step(x+1,y,x,y) )
         return 1;
      /* links unten */
      else if( x+1&lt;14 &amp;&amp; y-1&gt;0 &amp;&amp; spielfeld[x+1][y-1]!='*'
               &amp;&amp; xalt!=x+1 &amp;&amp; yalt!=y-1 &amp;&amp; besucht[x+1][y-1]!=1
               &amp;&amp; step(x+1,y-1,x,y) )
         return 1;
      /* nach oben */
      else if( x-1&gt;0 &amp;&amp; spielfeld[x-1][y] !='*'
               &amp;&amp; xalt!=x-1 &amp;&amp; besucht[x-1][y]!=1
               &amp;&amp; step(x-1,y,x,y) )
         return 1;
      /* nach links */
      else if( y-1&gt;0 &amp;&amp; spielfeld[x][y-1] !='*'
               &amp;&amp; yalt!=y-1 &amp;&amp; besucht[x][y-1]!=1
               &amp;&amp; step(x,y-1,x,y) )
         return 1;
      /* links oben */
      else if( x-1&gt;0 &amp;&amp; y-1&gt;0 &amp;&amp; spielfeld[x-1][y-1] !='*'
               &amp;&amp; xalt!=x-1 &amp;&amp; yalt!=y-1 &amp;&amp; besucht[x-1][y-1]!=1
               &amp;&amp; step(x-1,y-1,x,y) )
         return 1;
   }
   spielfeld[x][y]=' ';
   return 0;
}

int main(void) {
   createspielfeld();
   step(1,1,1,1);
   return EXIT_SUCCESS;
}</pre></div>
<p>Auch wenn Ihnen das ganze Thema recht komplex erscheinen mag, so entspricht dies doch einem logischen Ablauf. Man muss eben 1 zurückgeben, wenn der Weg, den man probiert hat, ans Ziel führt. Befindet man sich in einer Sackgasse, muss man einen anderen Wert zurückgeben (in diesem Beispiel 0). Außerdem sollte man einen Weg, den man schon einmal gegangen ist, nicht nochmals zurückgehen (da dieser bekanntlich nicht zum Ziel führt). Mit dieser Strategie kommen Sie durch einen beliebig komplexen Irrgarten immer ans Ziel (sofern ein Weg zum Ziel existiert und der Irrgarten nicht so komplex ist, dass es einen Stack-Überlauf gibt).</p><a id="mjdf73b2552404835ed8da47e6fc60f70c" name="mjdf73b2552404835ed8da47e6fc60f70c"></a><a name="t32"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t33"></a><h3 class="t3"><span class="cfett">22.8.2</span><span class="cfett"> Das 8-Dame-Problem</span>  <img src="common/15x15leer.gif" width="15" height="15" border="0" alt="top"><a href="#t2t32"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Ein etwas weiter verbreitetes Beispiel für das Backtracking ist das 8-Dame-Problem. Die Aufgabe lautet: »Positionieren Sie 8 Damen auf einem Schachbrett so, dass diese sich nicht gefährden.« Für diejenigen, die es nicht wissen: Die Dame kann von ihrer aktuellen Position aus beliebig viele Felder in der gleichen Spalte, in der gleichen Reihe oder in den Diagonalen rücken &#8211; was bedeutet, dass in diesen Richtungen keine andere Dame stehen darf. Versuchen Sie es mal auf dem Schachbrett nachzuahmen. Es gibt exakt 92 Möglichkeiten.</p>
<p>Sie haben hierbei die Möglichkeit, ein zweidimensionales Array für das Schachbrett zu verwenden, aber da sich zwei Damen in der gleichen Reihe oder Spalte sowieso bedrohen würden, können Sie sich das ersparen. Da die erste Dame, die Sie setzen, keine Bedrohung zu befürchten hat, setzen wir diese gleich an die rechte obere Ecke. Somit könnte der Funktionsaufruf wie folgt aussehen:</p>
<div class="listing"><pre class="prettyprint">int schachbrett[8];
int i;

for(i = 0; i &lt; 8; i++)
   schachbrett[i] = 0;
/* Dame an die linke obere Ecke */
dame(schachbrett, 7);</pre></div>
<p>Hierzu nun ein Teil der Funktion <span class="clisting">dame()</span>:</p>
<div class="listing"><pre class="prettyprint">int dame(int *schachbrett, int position) {
    int x = 1;
    static int counter = 1;
    while(x&lt;=8) {
       schachbrett[position] = x;</pre></div>
<p>Der Wert <span class="clisting">x</span> dient zur Identifizierung der einzelnen Damen. Jede Dame bekommt eine Nummer. Des Weiteren dient dieser Wert auch noch zur Überprüfung, ob eine Dame in der Diagonalen gefährdet wird. Aber dazu später mehr. Mit der Zeile</p>
<div class="listing"><pre class="prettyprint">schachbrett[position] = x;</pre></div>
<p>bekommt das Feld 7 (genauer Feld 8,  aber da hier 0 ebenfalls als erstes Feld präsent ist, eben 0 bis 7 anstatt 1 bis 8) rechts oben den Wert 1:</p>
<div class="bildbox">
<p><a name="IDA4KVQ"></a><a onClick="OpenWin('bilder/22_040.gif','Abbildung',800,800)"><img border="0" src="bilderklein/klein22_040.gif" alt="Abbildung"><br><span class="tabunter">Hier klicken, um das Bild zu vergrößern</span></a></p>
</div>
<p class="tabunter"><strong>Abbildung 22.40    </strong>Die erste Dame wurde rechts oben gesetzt (1).</p>
<p>Als Nächstes benötigen Sie eine Funktion, um zu testen, ob die Dame mit der Nummer 1 auf der Reihe, Spalte und Diagonalen mit einer anderen Dame kollidiert:</p>
<div class="listing"><pre class="prettyprint">if(!dame_in_gefahr(schachbrett))</pre></div>
<p>Der Funktion übergeben Sie lediglich die Daten vom Schachbrett. Im ersten Durchlauf wird die Bedingung logischerweise wahr sein &#8211; d.  h., die Dame ist nicht in Gefahr.</p>
<p>Jetzt müssen Sie überprüfen, ob Sie nicht schon an Position 0 angekommen sind (bildlich wäre das, in einer Spalte ganz unten angekommen zu sein):</p>
<div class="listing"><pre class="prettyprint">if(position)</pre></div>
<p>Falls Sie noch nicht die ganze Spalte durch haben, beginnt ab hier der erste rekursive Aufruf (und eine Erhöhung des Stacks):</p>
<div class="listing"><pre class="prettyprint">// die nächste Dame setzen
if(dame(schachbrett,position-1))
   return 1;</pre></div>
<p>Nochmals die Funktion bis hierher im Überblick:</p>
<div class="listing"><pre class="prettyprint">int dame(int *schachbrett, int position) {
   int x = 1;
   static int counter = 1;

   while(x &lt;= 8) {
      schachbrett[position]=x;
      if(!dame_in_gefahr(schachbrett)) {
         if(position) {
            /* die nächste Dame ... */
            if(dame(schachbrett,position-1))
               return 1;   /* Dame an diese Position setzen */
         }
         else
            return 1;</pre></div>
<p>Mit dem erneuten Funktionsaufruf sieht die Situation folgendermaßen auf dem Schachbrett aus:</p>
<div class="bildbox">
<p><a name="IDAKMVQ"></a><a onClick="OpenWin('bilder/22_041.gif','Abbildung',800,800)"><img border="0" src="bilderklein/klein22_041.gif" alt="Abbildung"><br><span class="tabunter">Hier klicken, um das Bild zu vergrößern</span></a></p>
</div>
<p class="tabunter"><strong>Abbildung 22.41    </strong>Erster rekursiver Funktionsaufruf &#8211; eine weitere Dame</p>
<p>Jetzt ist eine Dame an Position 7 in Gefahr, und folgende Bedingung trifft nicht zu:</p>
<div class="listing"><pre class="prettyprint">if(!dame_in_gefahr(schachbrett))</pre></div>
<p>Folglich wird der Zähler <span class="clisting">x</span> um 1 inkrementiert:</p>
<div class="listing"><pre class="prettyprint">x++;</pre></div>
<p>Bildlich dargestellt, ergibt sich nun durch folgende Code-Zeile folgender Zustand auf dem Schachbrett:</p>
<div class="listing"><pre class="prettyprint">schachbrett[position]=x;</pre></div>
<div class="bildbox">
<p><a name="IDAWMVQ"></a><a onClick="OpenWin('bilder/22_042.gif','Abbildung',800,800)"><img border="0" src="bilderklein/klein22_042.gif" alt="Abbildung"><br><span class="tabunter">Hier klicken, um das Bild zu vergrößern</span></a></p>
</div>
<p class="tabunter"><strong>Abbildung 22.42    </strong>Ein weiterer Zug der zweiten Dame</p>
<p>Auch in dieser Stellung liegt eine Kollision vor. Also wird <span class="clisting">x</span> nochmals inkrementiert, womit Sie folgenden Zustand vorfinden:</p>
<div class="bildbox">
<p><a name="IDA3MVQ"></a><a onClick="OpenWin('bilder/22_043.gif','Abbildung',800,800)"><img border="0" src="bilderklein/klein22_043.gif" alt="Abbildung"><br><span class="tabunter">Hier klicken, um das Bild zu vergrößern</span></a></p>
</div>
<p class="tabunter"><strong>Abbildung 22.43    </strong>Ein weiterer Zug, und es ist keine Kollision mehr vorhanden.</p>
<p>Jetzt gefährden sich beide Damen nicht mehr, und somit wird wieder ein erneuter rekursiver Funktionsaufruf ausgeführt. Der Stand der aktuellen Funktion wird wieder auf den Stack getan (zweite Funktion auf dem Stack) und wartet wiederum auf ihren Einsatz. Jetzt geht das Spiel von Neuem los. Der nächste Schritt sieht bildlich so aus (siehe Abbildung 22.44).</p>
<div class="bildbox">
<p><a name="IDACNVQ"></a><a onClick="OpenWin('bilder/22_044.gif','Abbildung',800,800)"><img border="0" src="bilderklein/klein22_044.gif" alt="Abbildung"><br><span class="tabunter">Hier klicken, um das Bild zu vergrößern</span></a></p>
</div>
<p class="tabunter"><strong>Abbildung 22.44    </strong>Der zweite rekursive Funktionsaufruf von »dame()«</p>
<p>Da die Dame in den nächsten drei Reihen sowieso kollidiert, überspringen wir diese drei Schritte, wo jeweils der Wert von <span class="clisting">x</span> dreimal inkrementiert wird, bis folgende Stellung erreicht wurde:</p>
<div class="bildbox">
<p><a name="IDAJNVQ"></a><a onClick="OpenWin('bilder/22_045.gif','Abbildung',800,800)"><img border="0" src="bilderklein/klein22_045.gif" alt="Abbildung"><br><span class="tabunter">Hier klicken, um das Bild zu vergrößern</span></a></p>
</div>
<p class="tabunter"><strong>Abbildung 22.45    </strong>Es ist keine Kollision mehr vorhanden.</p>
<p>Wohl gemerkt heißt das noch lange nicht, dass dies die endgültige Stellung darstellt, da alle diese Funktionsaufrufe noch auf dem Stack liegen und darauf warten, was mit ihnen passieren soll (1 = bleibt so; 0 = weitersuchen). Nach weiteren rekursiven Funktionsaufrufen passiert endlich etwas:</p>
<div class="bildbox">
<p><a name="IDAONVQ"></a><a onClick="OpenWin('bilder/22_046.gif','Abbildung',800,800)"><img border="0" src="bilderklein/klein22_046.gif" alt="Abbildung"><br><span class="tabunter">Hier klicken, um das Bild zu vergrößern</span></a></p>
</div>
<p class="tabunter"><strong>Abbildung 22.46    </strong>Noch gibt es keine Kollision.</p>
<p>Der nächste Funktionsaufruf (für die erste Spalte) wird nun den Wert 0 zurückgeben, da sich in der ersten Spalte keine Dame platzieren lässt, ohne dass diese sich mit einer anderen gefährdet. Jetzt »trackt« unsere Funktion zur zweiten Spalte »back«.</p>
<p>Der Wert von <span class="clisting">x,</span> der auf dem Stack gespeichert wurde, betrug in der zweiten Spalte 6, somit wird dieser wieder inkrementiert und es geht in Zeile 7 (zweite Spalte) weiter. Dort findet eine weitere Kollision statt, ebenso wie in der Zeile 8 (zweite Spalte). Somit bekommt auch der Aufrufer der zweiten Spalte den Wert 0 zurück, und unser Programm nimmt seine Ausführung in der dritten Spalte (von links) und der vierten Zeile (Wert von <span class="clisting">x</span> ist hier 4) wieder auf. Weitere Inkrementierungen in dieser Spalte bringen auch keinen Erfolg, sondern nur weitere Kollisionen.</p>
<p>Dies geht so lange weiter zurück, bis entweder keine Kollision mehr stattfindet (dann geht es wieder »nach vorne« weiter) oder die Bedingung</p>
<div class="listing"><pre class="prettyprint">if(position)</pre></div>
<p>unwahr wird. Das heißt, wir sind am Ende angekommen. Dies wird mit einem <span class="clisting">return 1</span> bestätigt:</p>
<div class="listing"><pre class="prettyprint">if(position) {
   if(dame(schachbrett,position-1))
      return 1; //Dame an diese Position setzten
}
else
  <span class="cfett"> return 1;</span> <span class="cfett"> //Wir sind fertig, wir haben eine Lösung</span></pre></div>
<p>... oder aber auch, wenn Sie alle 92 Möglichkeiten ausgeben wollen. Wir benutzten Letzteres. Ich empfehle Ihnen, um das ganze Programm besser zu verstehen, es Schritt für Schritt auf einem Schachbrett nachzuspielen.</p>
<p>Hierzu noch das komplette Listing, das das 8-Dame-Problem programmtechnisch auflöst:</p>
<div class="listing"><pre class="prettyprint">/* 8dame.c */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int dame_in_gefahr(int *schachbrett) {
   /* x==nach unten; y==nach rechts */
   int x,y;
   for(x=0; x&lt;7; x++)
      /* Ist auf feld[x] eine Dame? */
      if(schachbrett[x])
      for(y=x+1; y&lt;=7; y++)
         /* Ist auf feld[y] eine Dame? */
         if(schachbrett[y])  {
            /* Wir überprüfen, ob die beiden
             * Damen kollidieren. */
            /* Sind beide Damen in derselben Zeile? */
            if(schachbrett[x]==schachbrett[y])
               return 1; /* Kollision in gleicher Zeile */
            /* Diagonal? */
            if(abs(x-y)==abs(schachbrett[x]-schachbrett[y]))
              return 2; /* Kollision in der Diagonalen */
         }
   return 0; /* keine Kollision! */
}

int dame(int *schachbrett, int position) {
   int x = 1, i;
   static int counter = 1;

   while(x &lt;= 8) {
      /* Wir setzen die Dame mit der
       * Nummer x an feld[position]. */
      schachbrett[position]=x;
      if(!dame_in_gefahr(schachbrett)) {
         if(position) {
            /* die nächste Dame */
            if(dame(schachbrett,position-1))
               return 1; /* Dame an diese Position setzen */
         }
         else {
            printf("Loesungs-Nr.%2d : ", counter++);
            for(i=0; i&lt;8; i++)
               printf("(%d,%d)", i+1, schachbrett[i]);
            printf("\n");
         }
      }
      x++;
   }
   schachbrett[position] = 0;
   return 0;
}

int main(void) {
   int schachbrett[8], x;

   for(x=0; x &lt; 8; x++)
      schachbrett[x] = 0;
   dame(schachbrett,7);
   return EXIT_SUCCESS;
}</pre></div>
<p>In der Zeile</p>
<div class="listing"><pre class="prettyprint">if(abs(x-y)==abs(schachbrett[x]-schachbrett[y]))</pre></div>
<p>wird eine absolute Zahl berechnet, das heißt beispielsweise, der absolute Wert von 2&#8211;6 ist 4 und nicht &#8211;4. Diese Berechnung und Bedingung dient dazu, zu überprüfen, ob in der Diagonalen eine Kollision mit einer Dame stattfindet.</p>
<p>Hier sehen Sie noch eine der 92 möglichen Lösungen:</p>
<div class="bildbox">
<p><a name="IDALSVQ"></a><a onClick="OpenWin('bilder/22_047.gif','Abbildung',800,800)"><img border="0" src="bilderklein/klein22_047.gif" alt="Abbildung"><br><span class="tabunter">Hier klicken, um das Bild zu vergrößern</span></a></p>
</div>
<p class="tabunter"><strong>Abbildung 22.47    </strong>Keine Dame ist gefährdet.</p><br><hr><a name="kommentar"></a><h3>Ihr Kommentar</h3>
                       Wie hat Ihnen das &lt;openbook&gt; gefallen? Wir freuen uns immer über Ihre freundlichen und kritischen Rückmeldungen.
                       <form action="http://www.galileo-press.de/feedback/openbook" method="post" style="text-align: center; margin-top: 10px;"><input type="hidden" name="openbookurl" value="http://openbook.galileocomputing.de/c_von_a_bis_z/022_c_algorithmen_008.htm"><input type="hidden" name="buchtitel" value="C von A bis Z"><input type="hidden" name="Kapitel" value="22.8 Backtracking"><table border="0">
<tr>
<td><label for="name">Name</label><br></td>
<td><input type="text" name="name" id="name" size="40"><br></td>
</tr>
<tr>
<td><label for="email">E-Mail</label><br></td>
<td><input type="text" name="email" id="email" size="40"><br></td>
</tr>
<tr>
<td valign="top"><label for="comment">Ihr Kommentar</label><br></td>
<td><textarea name="comment" id="comment" rows="10" cols="40"></textarea><br></td>
</tr>
<tr>
<td>
</td>
<td><input type="submit" value="Kommentar absenden"></td>
</tr>
</table>
</form>
</div></td>
</tr>
</table></td>
</tr>
<tr>
<td width="100%" class="start" colspan="1" height="22" align="center"><table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="25%"><a href="022_c_algorithmen_007.htm" class="navnav"> &lt;&lt;   zurück</a></td>
<td width="49%"><div align="center"><a class="navnav" href="#">&lt;top&gt;</a></div></td>
<td align="right" width="25%"><div align="right"><a href="023_c_cgi_001.htm" class="navnav">vor   &gt;&gt; </a></div></td>
</tr>
</table></td>
</tr>
</table>
</div></td>
<td width="10" valign="top">&nbsp;&nbsp;</td>
<td width="160" valign="top">
<table border="0" cellpadding="0" cellspacing="0" width="160">
<tr>
<td>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td class="tbl2" height="20" colspan="2">
&nbsp;<a href="http://www.galileocomputing.de/?GPP=opc3" class="nav">
<strong>Zum Katalog</strong></a>
</td>
</tr>
<tr>
<td valign="top" class="tbl2" width="2">
<img src="common/leer.gif" border="0" height="1" width="1"></td>
<td valign="top">
<table cellspacing="3">
<tr>
<td><a href="http://www.galileocomputing.de/2132?GPP=opc3">
<img src="common/9783836214117_s.gif" width="113" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: C von A bis Z" title="Zum Katalog: C von A bis Z">
<br /><br /><strong>&nbsp;C von A bis Z</strong><br /><img src="common/pfeil_rechts5.gif" border="0" alt="">Jetzt&nbsp;bestellen</a><br /><br />
</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td><img src="common/leer.gif" height="2" width="1" border="0" /></td>
</tr>
<tr>
<td>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td class="tbl2" height="20" colspan="2"><a href="#kommentar" class="nav"><strong>&nbsp;Ihre Meinung?</strong></a>
</td>
</tr>
<tr>
<td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td>
<td valign="top">
<table cellspacing="3">
<tr>
<td>Wie hat Ihnen das &lt;openbook&gt; gefallen?<br /><a href="#kommentar"><img src="common/pfeil_rechts5.gif" border="0" alt="">Ihre Meinung</a>
<br /><br /></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td><img src="common/leer.gif" height="2" width="1" border="0" /></td>
</tr>
<tr>
<td>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td class="tbl2" height="20" colspan="2">&nbsp;<a href="http://www.galileocomputing.de/?GPP=opc3" class="nav"><strong>Buchtipps</strong></a></td>
</tr>
<tr> 
<td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
<a href="http://www.galileocomputing.de/2083?GPP=opc3">
<img src="common/9783836213851_s.gif" width="112" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Einstieg in C++" title="Zum Katalog: Einstieg in C++"><br /><br /><br /><br /><br /><br /><br />&nbsp;Einstieg in C++</a><br /><br /></td>
</tr>
<tr>
<td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
<a href="http://www.galileocomputing.de/2156?GPP=opc3">
<img src="common/9783836214292_s.gif" width="113" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: C++ von A bis Z" title="Zum Katalog: C++ von A bis Z"><br /><br /><br /><br /><br /><br /><br />&nbsp;C++ von A bis Z</a><br /><br /></td>
</tr>
<tr>
<td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
<a href="http://www.galileocomputing.de/1299?GPP=opc3">
<img src="common/9783898428392_s.gif" width="113" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: C/C++" title="Zum Katalog: C/C++"><br /><br /><br /><br /><br /><br /><br />&nbsp;C/C++</a><br /><br /></td>
</tr>
<tr>
<td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
<a href="http://www.galileocomputing.de/1712?GPP=opc3">
<img src="common/9783836211574_s.gif" width="113" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Shell-Programmierung" title="Zum Katalog: Shell-Programmierung"><br /><br /><br /><br /><br /><br /><br />&nbsp;Shell-Programmierung</a><br /><br /></td>
</tr>
<tr>
<td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
<a href="http://www.galileocomputing.de/2049?GPP=opc3">
<img src="common/9783836213660_s.gif" width="119" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Linux-UNIX-Programmierung" title="Zum Katalog: Linux-UNIX-Programmierung"><br /><br /><br /><br /><br /><br /><br />&nbsp;Linux-UNIX-<br />&nbsp;Programmierung</a><br /><br /></td>
</tr>
<tr>
<td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
<a href="http://www.galileocomputing.de/2138?GPP=opc3">
<img src="common/9783836214209_s.gif" width="107" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: IT-Handbuch für Fachinformatiker" title="Zum Katalog: IT-Handbuch für Fachinformatiker"><br /><br /><br /><br /><br /><br /><br />&nbsp;IT-Handbuch für <br />&nbsp;Fachinformatiker</a><br /><br /></td>
</tr>
<tr>
<td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
<a href="http://www.galileocomputing.de/2165?GPP=opc3">
<img src="common/9783836214391_s.gif" width="119" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Ubuntu GNU/Linux" title="Zum Katalog: Ubuntu GNU/Linux"><br /><br /><br /><br /><br /><br /><br />&nbsp;Ubuntu GNU/Linux</a><br /><br /></td>
</tr>
<tr>
<td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
<a href="http://www.galileocomputing.de/1628?GPP=opc3">
<img src="common/9783836211161_s.gif" width="117" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Coding for Fun" title="Zum Katalog: Coding for Fun"><br /><br /><br /><br /><br /><br /><br /><br />&nbsp;Coding for Fun&nbsp;</a><br /><br /></td>
</tr>
</table></td>
</tr>
<tr>
<td><img src="common/leer.gif" height="2" width="1" border="0" /></td>
</tr>
<tr>
<td>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td class="tbl2" height="20" colspan="2"><strong>&nbsp;Shopping</strong></td>
</tr>
<tr>
<td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td>
<td valign="top">
<table cellspacing="3">
<tr>
<td><b>Versandkostenfrei</b> bestellen in Deutschland und &Ouml;sterreich<br /><a href="http://www.galileocomputing.de/hilfe/Shop/?GPP=opc3"><img src="common/pfeil_rechts5.gif" border="0" alt="Info">Info</a><br /><br /></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table><br><br><hr width="70%" align="center">
<div align="center">
<p class="standard"><strong>Copyright © Galileo Press 2009</strong><br>
        Für Ihren privaten Gebrauch dürfen Sie die Online-Version natürlich ausdrucken.
        Ansonsten unterliegt das &lt;openbook&gt; denselben Bestimmungen, wie die
        gebundene Ausgabe: Das Werk einschließlich aller seiner Teile ist urheberrechtlich
        geschützt. Alle Rechte vorbehalten einschließlich der Vervielfältigung, Übersetzung,
        Mikroverfilmung sowie Einspeicherung und Verarbeitung in elektronischen Systemen.</p><br><a href="http://www.galileocomputing.de/">[Galileo Computing]</a><br><br>
      Galileo Press, Rheinwerkallee 4, 53227 Bonn, Tel.: 0228.42150.0, Fax 0228.42150.77, <a href="mailto:info@galileo-press.de">info@galileo-press.de</a></div><br><br></body>
</html>
