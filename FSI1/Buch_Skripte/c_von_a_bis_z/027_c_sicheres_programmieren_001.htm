<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>Galileo Computing :: C von A bis Z &ndash; 27 Sicheres Programmieren</title>
<meta name="title" content="Galileo Computing :: C von A bis Z - 27 Sicheres Programmieren">
<meta name="author" content="J&uuml;rgen Wolf ">
<meta name="publisher" content="Galileo Press 2009">
<meta name="copyright" content="Galileo Press 2009">
<meta name="Description" content="C von A bis Z - Das umfassende Handbuch &ndash; 27 Sicheres Programmieren">
<meta name="audience" content="Alle">
<meta name="robots" content="INDEX,FOLLOW">
<meta http-equiv="content-language" content="de">
<link rel="stylesheet" type="text/css" href="common/galileo_open.css">
<link rel="prev" href="026_c_paralleles_rechnen_004.htm">
<link rel="next" href="027_c_sicheres_programmieren_002.htm"><script type="text/javascript"><!--
    function OpenWin(url,name,height,width)
    {
      var InfoWin = window.open(url,name,"directories=0,height="+height+",width=" + width + ",hotkeys=0,location=0,menubar=0,resizable=1,screenX=150,screenY=10,left=150,top=10,scrollbars=1,status=1,titlebar=0,toolbar=0");
      InfoWin.focus();
    }
    //--></script><link href="common/prettify.css" type="text/css" rel="stylesheet"><script type="text/javascript" src="common/prettify.js"></script></head>
<body vlink="#000099" link="#000099" alink="#000099" onload="prettyPrint()">
<table width="100%" border="0" cellpadding="0" cellspacing="0" bgcolor="#000066">
<tr>
<td height="74" valign="bottom" colspan="2"><a href="http://www.galileocomputing.de/katalog/openbook?GPP=opc3"><img src="common/galileocomputing_openbook.gif" width="200" height="56" border="0" alt="Galileo Computing < openbook >" title="Galileo Computing < openbook >"></a></td>
<td width="80" height="74"><a href="http://www.galileocomputing.de/?GPP=opc3"><img src="common/galileocomputing.gif" border="0" alt="Galileo Computing - Professionelle Bücher. Auch für Einsteiger." title="Galileo Computing - Professionelle Bücher. Auch für Einsteiger."></a></td>
</tr>
</table>
<div align="right"><a href="http://www.galileocomputing.de/?GPP=opc3" class="navnav">Professionelle Bücher. Auch für Einsteiger.</a></div><br><table class="tbl" border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td width="190" valign="top">
<table class="tbl1" border="0" cellpadding="3" cellspacing="0" width="190" align="left">
<tr>
<td class="tbl2"><a class="nav" href="index.htm#_top">Inhaltsverzeichnis</a></td>
</tr>
<tr>
<td><a class="navnav" href="000_c_vorwort_001.htm#mj764cb3fd439d3b95d1843e7c7d17f235">Vorwort</a></td>
</tr>
<tr>
<td><a class="navnav" href="000_c_vorwort_gutachter_001.htm#mj3d41cb339c9b2fc1d6e99cdaa93c3860">Vorwort des Gutachters</a></td>
</tr>
<tr>
<td><a class="navnav" href="001_c_einstieg_in_c_001.htm#mja24d93ff97bb42dbebf4689160c45195">1 Einstieg in C</a></td>
</tr>
<tr>
<td><a class="navnav" href="002_c_das_erste_programm_001.htm#mj2604a667cc98d3fa2178751273346b91">2 Das erste Programm</a></td>
</tr>
<tr>
<td><a class="navnav" href="003_c_grundlagen_001.htm#mj7ac54ba315b94149806c1de3fc89ee7f">3 Grundlagen</a></td>
</tr>
<tr>
<td><a class="navnav" href="004_c_ein_ausgabe_001.htm#mj20c131820fbfb1497afd796ee443599e">4 Formatierte Ein-/Ausgabe mit »scanf()« und »printf()«</a></td>
</tr>
<tr>
<td><a class="navnav" href="005_c_basisdatentypen_001.htm#mjeda2957449ddc812dad62b400fe57752">5 Basisdatentypen</a></td>
</tr>
<tr>
<td><a class="navnav" href="006_c_operatoren_001.htm#mjab3693b096d581607801a36ce88905fc">6 Operatoren</a></td>
</tr>
<tr>
<td><a class="navnav" href="007_c_typumwandlung_001.htm#mj5c5e497ac2ab4367fe9df0ffd218cfca">7 Typumwandlung</a></td>
</tr>
<tr>
<td><a class="navnav" href="008_c_kontrollstrukturen_001.htm#mjc7bf6f584a2fe20b4c5f6b16ba15d57d">8 Kontrollstrukturen</a></td>
</tr>
<tr>
<td><a class="navnav" href="009_c_funktionen_001.htm#mj7893101be51aa469fe52334038acd465">9 Funktionen</a></td>
</tr>
<tr>
<td><a class="navnav" href="010_c_praeprozessor_001.htm#mjacdd200a20163a4d3fa418b6cb95763e">10 Präprozessor-Direktiven</a></td>
</tr>
<tr>
<td><a class="navnav" href="011_c_arrays_001.htm#mje29de26c54a3884f7316cbbb2a073ad8">11 Arrays</a></td>
</tr>
<tr>
<td><a class="navnav" href="012_c_zeiger_001.htm#mjee28a882ef9125d2c4cc49121b2c65c1">12 Zeiger (Pointer)</a></td>
</tr>
<tr>
<td><a class="navnav" href="013_c_kommandozeilenargumente_001.htm#mjf6a9e42fa3bc25b2b1e06270e7bf8f68">13 Kommandozeilenargumente</a></td>
</tr>
<tr>
<td><a class="navnav" href="014_c_dyn_speicherverwaltung_001.htm#mj8d062301d2449b13710f1484d499cd9b">14 Dynamische Speicherverwaltung</a></td>
</tr>
<tr>
<td><a class="navnav" href="015_c_strukturen_001.htm#mj5e146ba18168113a5c645cd2d07c4ec8">15 Strukturen</a></td>
</tr>
<tr>
<td><a class="navnav" href="016_c_ein_ausgabe_funktionen_001.htm#mj136f9ac6b5b7c440aafe5010411ef011">16 Ein-/Ausgabe-Funktionen</a></td>
</tr>
<tr>
<td><a class="navnav" href="017_c_dateien_verzeichnisse_001.htm#mj9f81aea722a9edb8d0080df81eb9402c">17 Attribute von Dateien und das Arbeiten mit Verzeichnissen (nicht ANSI C)</a></td>
</tr>
<tr>
<td><a class="navnav" href="018_c_stdarg_h_001.htm#mj9d64febdc46a1375e5c4498b17154e30">18 Arbeiten mit variabel langen Argumentlisten &#8211; &lt;stdarg.h&gt;</a></td>
</tr>
<tr>
<td><a class="navnav" href="019_c_zeitroutinen_001.htm#mj0a8102e96a1297bd767ac7274e069f0f">19 Zeitroutinen</a></td>
</tr>
<tr>
<td><a class="navnav" href="020_c_headerdateien_001.htm#mjf3caede8ebd504dc6b7454b297c251e8">20 Weitere Headerdateien und ihre Funktionen (ANSI C)</a></td>
</tr>
<tr>
<td><a class="navnav" href="021_c_dyn_datenstrukturen_001.htm#mja75ba2f4ab8f95e9e321d195c1e26d76">21 Dynamische Datenstrukturen</a></td>
</tr>
<tr>
<td><a class="navnav" href="022_c_algorithmen_001.htm#mj07afe6f332eab2e8168da2f69f7b31c4">22 Algorithmen</a></td>
</tr>
<tr>
<td><a class="navnav" href="023_c_cgi_001.htm#mj6c4219b4e615fa24deaa57d5c3d04db8">23 CGI mit C</a></td>
</tr>
<tr>
<td><a class="navnav" href="024_c_mysql_001.htm#mj12dab301033f9fd856aa739270c45e08">24 MySQL und C</a></td>
</tr>
<tr>
<td><a class="navnav" href="025_c_netzwerkprogrammierung_001.htm#mja8101c6e0e4cb2e6fd8312114dad30d7">25 Netzwerkprogrammierung und Cross&ndash;Plattform-Entwicklung</a></td>
</tr>
<tr>
<td><a class="navnav" href="026_c_paralleles_rechnen_001.htm#mj710dc0ad851d57e60533f8797ff9c1e6">26 Paralleles Rechnen</a></td>
</tr>
<tr>
<td><a class="navh" href="##mj13eba8f9d68ac8414bffaa3a1b24ec31">27 Sicheres Programmieren</a></td>
</tr>
<tr>
<td><a class="navnav" href="028_c_weiterfuehrendes_001.htm#mj3e65f750149ade087925f303b3871af9">28 Wie geht&#8217;s jetzt weiter?</a></td>
</tr>
<tr>
<td><a class="navnav" href="029_c_anhang_a_001.htm#mjec9bf1c5e3fe2e46047c2f9c7aa9c531">A Operatoren</a></td>
</tr>
<tr>
<td><a class="navnav" href="030_c_anhang_b_001.htm#mj803443bb6e7546011c48e6e57fbdbb64">B Die C-Standard-Bibliothek</a></td>
</tr>
<tr>
<td><a class="navnav" href="stichwort.htm#_top">Stichwort</a></td>
</tr>
<tr>
<td><br><a href="http://download.galileo-press.de/openbook/c_von_a_bis_z/galileocomputing_c_von_a_bis_z.zip" class="navnav"><strong>Download:</strong><br>- ZIP, ca. 10,6 MB</a></td>
</tr>
<tr>
<td><a href="http://www.galileocomputing.de/2132?GPP=opc3" class="navnav">Buch bestellen</a></td>
</tr>
<tr>
<td><a class="navnav" href="#kommentar">Ihre Meinung?</a><br><br></td>
</tr>
</table>
</td>
<td width="10"><img src="common/spacer10.gif" width="10" height="10" alt="Spacer"></td>
<td width="85%" valign="top" align="center"><div align="center">
<table width="98%" border="0" cellspacing="0" cellpadding="0" bgcolor="#FFFFFF">
<tr>
<td width="100%" class="start" colspan="1" height="22" align="center"><table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="25%"><a href="026_c_paralleles_rechnen_004.htm" class="navnav"> &lt;&lt;   zurück</a></td>
<td width="49%"><div align="center"><a href="http://www.galileocomputing.de/?GPP=opc3" class="navnav">Galileo Computing</a> / <a href="http://www.galileocomputing.de/katalog/openbook/?GPP=opc3" class="navnav">&lt;openbook&gt;</a> / <a href="index.htm" class="navnav"> C von A bis Z</a></div></td>
<td align="right" width="25%"><div align="right"><a href="027_c_sicheres_programmieren_002.htm" class="navnav">vor   &gt;&gt; </a></div></td>
</tr>
</table></td>
</tr>
<tr>
<td width="100%" valign="top"><table width="100%" border="0" cellpadding="10" cellspacing="0" class="box">
<tr>
<td colspan="2"><a href="http://www.galileocomputing.de/2132?GPP=opc3" class="buchtitel">C von A bis Z</a><span class="autor"> von J&uuml;rgen Wolf </span><br><span class="untertitel">Das umfassende Handbuch</span></td>
</tr>
<tr>
<td valign="top" width="211"><dl>
<dt><a href="http://www.galileocomputing.de/2132?GPP=opc3" class="navnav"><img src="common/9783836214117.gif" border="0" alt="Buch: C von A bis Z" title="Buch: C von A bis Z"></a></dt>
<dd><br><a href="http://www.galileocomputing.de/2132?GPP=opc3"><span class="autor"><strong>C von A bis Z</strong><br>3., aktualisierte und erweiterte Auflage, geb., mit CD und Referenzkarte<br>1.190 S., 39,90 Euro<br>Galileo Computing<br>ISBN 978-3-8362-1411-7</span></a></dd>
</dl></td>
<td width="80%"><table border="0">
<tr>
<td valign="baseline"><img src="common/pfeil_u.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="3" class="kap"><strong><a href="#mj13eba8f9d68ac8414bffaa3a1b24ec31" class="navh">27 Sicheres Programmieren</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="#mjb65bef6a7c379becd39a0e492bc5af73" class="navh">27.1 Buffer-Overflow (Speicherüberlauf)</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mj413be9e741bc9226ff3f5e288cf6d663" class="navh">27.1.1 Speicherverwaltung von Programmen</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mj576a97ce6648e0ca841b850218ae1fb5" class="navh">27.1.2 Der Stack-Frame</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mjf1156245a64da897d5394988bb36aa63" class="navh">27.1.3 Rücksprungadresse manipulieren</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mj58fbb1931bb9659959092772cce0518a" class="navh">27.1.4 Gegenmaßnahmen zum Buffer-Overflow während der Programmerstellung</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mj56e75077fd95adcf4f7658306721ac8d" class="navh">27.1.5 Gegenmaßnahmen zum Buffer-Overflow, wenn das Programm fertig ist</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mj603244ba9ef401163ae95c449f4b9db5" class="navh">27.1.6 Programme und Tools zum Buffer-Overflow</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mjf7021bcbac0f028124b849400da09938" class="navh">27.1.7 Ausblick</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="027_c_sicheres_programmieren_002.htm#mjb3e8d423175ffd571850698a469fe34d" class="navnav">27.2 Memory Leaks (Speicherlecks)</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="027_c_sicheres_programmieren_002.htm#mjf868c843129819c0ea929e64b6ebe9bf" class="navnav">27.2.1 Bibliotheken und Tools zu Memory Leaks</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="027_c_sicheres_programmieren_003.htm#mj0352ea15623e8c0dae2c8cc8aa0748fb" class="navnav">27.3 Tipps zu Sicherheitsproblemen</a></strong></td>
</tr>
</table><br></td>
</tr>
</table>
<table width="100%" cellpadding="20" cellspacing="0" border="0" bgcolor="#eeeeee">
<tr>
<td><div class="main">
<p class="anleser"><em><span class="ckursiv">In diesem Kapitel werden zwei Themen angesprochen, die vielleicht auf den ersten Blick nicht allzu interessant erscheinen: Buffer Overflows und Memory Leaks. Da diese beiden Probleme jedoch leider häufiger in Erscheinung treten, sollte sich jeder ernsthafte Programmierer mit ihnen auseinandersetzen.</span></em></p><a id="mj13eba8f9d68ac8414bffaa3a1b24ec31" name="mj13eba8f9d68ac8414bffaa3a1b24ec31"></a><h1 class="t1"><span class="cfett">27</span><span class="cfett"> Sicheres Programmieren</span></h1>
<p>Ein Aspekt, der oft übersehen wird, ist die sicherheitsbezogene Programmierung. Programmierer setzen oft Funktionen ein, von denen sie zwar wissen, dass diese nicht ganz sicher sind, aber sie wissen nicht, was diese unsicheren Funktionen bewirken können.</p>
<p>Sie haben nach langjähriger Programmiererfahrung zwar jeden Algorithmus im Kopf und ihnen kann keiner etwas vormachen, sie verwenden aber trotzdem weiter diese Funktionen, weil sie sie eben immer verwenden und nicht so genau wissen, was daran schlimm sein soll. Denn das Programm läuft doch. Richtig? &#8211; Nein, falsch!</p>
<p>Auch wenn der Konkurrenzkampf und der Zeitdruck bei der Fertigstellung eines Projekts heutzutage enorm sind, sollten Sie diese Einstellung überdenken und sich ernsthaft mit diesem Thema befassen.</p>
<p>Diese zunächst unscheinbaren Unsicherheiten von Beginn an zu berücksichtigen, ist ein Bestandteil von vorausschauender Programmentwicklung und trägt wesentlich zur Qualitätssicherung Ihrer Programme bei. Auf diese Weise begegnen Sie schon im Vorfeld unvorhersehbarem Ärger, und nachträglich entstehen hohe Kosten.</p>
<p>Ein Szenario: Sie haben für eine Firma ein Programm zur Verwaltung von Daten geschrieben. In der Firma haben einige gewiefte Mitarbeiter einen Weg gefunden, mithilfe Ihres Programms aus dem Verwaltungsprogramm zu springen, wodurch sie ins System gelangen und allerlei Unfug anrichten. Der Kunde wird mit Sicherheit kein Programm mehr von Ihnen entwickeln lassen. Also haben Sie auf jeden Fall schon einen Imageschaden. Da Sie aber versprochen haben, sich um das Problem zu kümmern, müssen Sie alles andere erst einmal stehen und liegen lassen. Damit haben Sie schon kostbare Zeit verloren, die Sie für andere Projekte hätten nutzen können. Da noch weitere Kunden dieses Produkt verwenden, müssen Sie auch diese informieren.</p>
<p>Jetzt ist es an der Zeit, ein Bugfix (Patch) zu schreiben, den der Kunde einspielen muss, um den Fehler zu beheben. Wenn Sie Glück haben, kann der Kunde das Programm unterbrechen und den Patch einspielen. Sollte der Kunde aber rund um die Uhr auf das Programm angewiesen sein, entstehen ihm Ausfallkosten.</p>
<p>Nachdem Sie den Patch aufgespielt haben, treten andere unerwartete Probleme mit dem Programm auf. Somit folgt dem Patch ein weiterer, womit wieder Zeit, Geld und Image verloren gehen. Ich denke, dass jedem schon einmal ein ähnliches Szenario mit einem Programm widerfahren ist.</p>
<p>Die meisten solcher Sicherheitsprobleme treten mit Programmen auf, die in C geschrieben wurden. Dies heißt allerdings nicht, dass C eine unsichere Sprache ist, sondern es bedeutet nur, dass sie eine der am häufigsten eingesetzten Sprachen ist. Viele Systemtools, Server, Datenbanken, aber auch grafische Oberflächen sind in C geschrieben.</p>
<p>Sie sehen also, dass es sich durchaus lohnt, diese Themen aufzugreifen und bei der Entwicklung von Programmen zu berücksichtigen.</p><a id="mjb65bef6a7c379becd39a0e492bc5af73" name="mjb65bef6a7c379becd39a0e492bc5af73"></a><a name="t21"></a><a name="t2t31"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div>
<h2 class="t2"><span class="cfett">27.1</span><span class="cfett"> Buffer-Overflow (Speicherüberlauf)</span>  <a href="#t2t32"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><img src="common/15x15leer.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></h2>
<p>Eines der bekanntesten und am häufigsten auftretenden Sicherheitsprobleme ist der Buffer-Overflow (dt.: Speicherüberlauf, Pufferüberlauf), häufig auch als <span class="ckursiv">Buffer Overrun</span> bezeichnet. Geben Sie einmal in einer Internet-Suchmaschine den Begriff »Buffer-Overflow« ein, und Sie werden angesichts der enormen Anzahl von Ergebnissen überrascht sein. Es gibt unzählige Programme, die für einen Buffer-Overflow anfällig sind. Das Ziel des Angreifers ist es dabei, den Buffer-Overflow auszunutzen, um in das System einzubrechen.</p>
<p>Die Aufgabe dieses Abschnitts ist es nicht, Ihnen beizubringen, wie Sie Programme hacken können, sondern zu erklären, was ein Buffer-Overflow ist, wie dieser ausgelöst wird und was Sie als Programmierer beachten müssen, damit Ihr Programm nicht anfällig dafür ist.</p>
<p>Für den Buffer-Overflow ist immer der Programmierer selbst verantwortlich. Der Overflow kann überall dort auftreten, wo Daten von der Tastatur, dem Netzwerk oder einer anderen Quelle aus in einen Speicherbereich mit statischer Größe ohne eine Längenüberprüfung geschrieben werden. Hier sehen Sie ein solches Negativbeispiel:</p>
<div class="listing"><pre class="prettyprint">/* bufferoverflow1.c */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

int main(void) {
   char *str = "0123456789012";
   char buf[10];

   strcpy(buf, str);
   printf("%s",buf);
   return EXIT_SUCCESS;
}</pre></div>
<p>Hier wurde ein Buffer-Overflow mit der Funktion <span class="clisting">strcpy()</span> erzeugt. Es wird dabei versucht, in den <span class="clisting">char</span>-Vektor, der Platz für 10 Zeichen reserviert hat, mehr als diese 10 Zeichen zu kopieren.</p>
<div class="bildbox">
<p><a name="IDAYEUQ"></a><a onClick="OpenWin('bilder/27_001.gif','Abbildung',800,800)"><img border="0" src="bilderklein/klein27_001.gif" alt="Abbildung"><br><span class="tabunter">Hier klicken, um das Bild zu vergrößern</span></a></p>
</div>
<p class="tabunter"><strong>Abbildung 27.1    </strong>Pufferüberlauf mit der Funktion »strcpy()«</p>
<p>Die Auswirkungen eines Buffer Overflows sind stark vom Betriebssystem abhängig. Häufig stürzt dabei das Programm ab, weil Variablen mit irgendwelchen Werten überschrieben wurden. Manches Mal bekommen Sie aber auch nach Beendigung des Programms eine Fehlermeldung zurück, etwa Speicherzugriffsfehler. Dies wird ausgegeben, wenn z. B. die Rücksprungadresse des Programms überschrieben wurde und das Programm irgendwo in eine unerlaubte Speicheradresse springt.</p>
<p>Wird aber bewusst diese Rücksprungadresse manipuliert und auf einen speziell von Ihnen erstellten Speicherbereich verwiesen bzw. gesprungen, der echten Code enthält, haben Sie einen sogenannten <span class="ckursiv">Exploit</span> erstellt.</p><a id="mj413be9e741bc9226ff3f5e288cf6d663" name="mj413be9e741bc9226ff3f5e288cf6d663"></a><a name="t31"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t32"></a><h3 class="t3"><span class="cfett">27.1.1</span><span class="cfett"> Speicherverwaltung von Programmen</span>  <a href="#t2t33"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t31"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Ein Programm besteht aus drei Speichersegmenten, die im Arbeitsspeicher liegen. Der Prozessor (CPU) holt sich die Daten und Anweisungen aus diesem Arbeitsspeicher. Damit der Prozessor unterscheiden kann, ob es sich bei den Daten um Maschinenbefehle oder den Datenteil mit den Variablen handelt, werden diese Speicherbereiche in einzelne Segmente aufgeteilt. In Abbildung 27.2 sind die einzelnen Segmente schematisch dargestellt.</p>
<div class="bildbox">
<p><a name="IDAMFUQ"></a><a onClick="OpenWin('bilder/27_002.gif','Abbildung',800,800)"><img border="0" src="bilderklein/klein27_002.gif" alt="Abbildung"><br><span class="tabunter">Hier klicken, um das Bild zu vergrößern</span></a></p>
</div>
<p class="tabunter"><strong>Abbildung 27.2    </strong>Speicherverwaltung &#8211; die einzelnen Segmente</p>
<ul class="gp">
<li><span class="ckursiv">Code-Segment (Text-Segment)</span> &#8211; Hier befinden sich die Maschinenbefehle, die vom Prozessor beim <span class="clisting">HOLEN</span>-Zyklus eingelesen werden &#8211; oder einfacher gesagt: der Programmcode selbst. Das Code-Segment lässt sich nicht manipulieren, hat eine feste Größe und ist gegen Überschreiben geschützt.</li>
</ul>
<ul class="gp">
<li><span class="ckursiv">Heap-Segment (Daten-Segment)</span> &#8211; Hier liegen die Variablen (<span class="clisting">extern</span>, <span class="clisting">static</span>), Felder (Arrays) und Tabellen des Programms. Der Maschinenbefehl, der diese Daten benötigt, greift auf dieses Segment zu.</li>
</ul>
<ul class="gp">
<li><span class="ckursiv">Stack-Segment</span> &#8211; Hier befinden sich dynamische Variablen und Rücksprungadressen von Funktionen. Dieser Bereich dient auch dem schnellen Zwischenspeichern von Daten und Parameterübergaben.</li>
</ul>
<p>Es sei hierbei noch erwähnt, dass der Stack-Bereich nach unten und der Heap nach oben anwächst. Der Stack ist auch das Angriffsziel für einen Buffer-Overflow.</p><a id="mj576a97ce6648e0ca841b850218ae1fb5" name="mj576a97ce6648e0ca841b850218ae1fb5"></a><a name="t32"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t33"></a><h3 class="t3"><span class="cfett">27.1.2</span><span class="cfett"> Der Stack-Frame</span>  <a href="#t2t34"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t32"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Für jede Funktion steht ein sogenannter Stack-Frame im Stack zur Verfügung, in dem die lokalen Variablen gespeichert werden. Wichtiger noch: Im Stack befinden sich Registerinhalte des Prozessors, die vor dem Funktionsaufruf gesichert wurden. Sie sind nötig, um bei Beendigung der Funktion auf die aufrufende Funktion zurückspringen zu können.</p>
<p>Beispielsweise wird in der <span class="clisting">main()</span>-Funktion die Funktion mit den Parametern <span class="clisting">my_func(wert1, wert2)</span> aufgerufen:</p>
<div class="listing"><pre class="prettyprint">/* stackframe.c */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void my_func(int wert1, int wert2) {
   int summe;

   summe = wert1+wert2;
   printf("Summe: %d \n",summe);
}

int main(void) {
   my_func(10,29);
   return 0;
}</pre></div>
<p>Dies geschieht jetzt &#8211; ohne zu sehr ins Detail zu gehen &#8211; in folgenden Schritten auf dem Stack:</p>
<table width="100%" border="0">
<tr>
<td valign="top" width="10"><strong>1.</strong></td>
<td valign="top" width="100%" align="left"> Mit dem Assembler-Befehl PUSH werden die Parameter wert1 und wert2 auf den Stack geschrieben.</td>
</tr>
<tr>
<td valign="baseline" width="16">     </td>
<td valign="top" width="100%" align="left">     </td>
</tr>
</table>
<table width="100%" border="0">
<tr>
<td valign="top" width="10"><strong>2.</strong></td>
<td valign="top" width="100%" align="left"> Mit dem Assembler-Befehl CALL wird die Position des Maschinencodes gesichert, damit bei Beendigung der Funktion my_func() wieder in die main()-Funktion zurückgesprungen werden kann. Dies wird mithilfe des Befehlszeigers (Instruction Pointer, kurz: IP) realisiert. Genau genommen wird diese Adresse mithilfe des Befehlszeigers, des Code-Segments (CS) (CS:IP) und des Basis-Pointers (BP) erzeugt. Dies ist die Rücksprungadresse, die mit CS:IP und BP dargestellt wird.</td>
</tr>
<tr>
<td valign="baseline" width="16">     </td>
<td valign="top" width="100%" align="left">     </td>
</tr>
</table>
<table width="100%" border="0">
<tr>
<td valign="top" width="10"><strong>3.</strong></td>
<td valign="top" width="100%" align="left"> Jetzt werden die lokalen Variablen der Funktion my_func() eingerichtet, und die Funktion arbeitet die einzelnen Befehle ab.</td>
</tr>
<tr>
<td valign="baseline" width="16">     </td>
<td valign="top" width="100%" align="left">     </td>
</tr>
</table>
<table width="100%" border="0">
<tr>
<td valign="top" width="10"><strong>4.</strong></td>
<td valign="top" width="100%" align="left"> Am Schluss, wenn diese Funktion beendet ist, springt sie wieder zur main()-Funktion zurück. Dies geschieht mit dem Assembler-Befehl RET, der auf die vom Stack gesicherte Adresse zurückspringt, die aus CS:IP und BP gebildet wird.</td>
</tr>
<tr>
<td valign="baseline" width="16">     </td>
<td valign="top" width="100%" align="left">     </td>
</tr>
</table><a id="mjf1156245a64da897d5394988bb36aa63" name="mjf1156245a64da897d5394988bb36aa63"></a><a name="t33"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t34"></a><h3 class="t3"><span class="cfett">27.1.3</span><span class="cfett"> Rücksprungadresse manipulieren</span>  <a href="#t2t35"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t33"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>In diesem Abschnitt folgt ein Beispiel, das zeigt, wie die Rücksprungadresse manipuliert werden kann.</p>
<p>Es ist hierbei nicht Ziel und Zweck, Ihnen eine Schritt-für-Schritt-Anleitung zur Programmierung eines Exploits an die Hand zu geben und bewusst einen Buffer-Overflow zu erzeugen, sondern Ihnen soll vor Augen geführt werden, wie schnell und unbewusst kleine Unstimmigkeiten im Quellcode Hackern Tür und Tor öffnen können &#8211; einige Kenntnisse der Funktionsweise von Assemblern vorausgesetzt.</p>
<p>Zur Demonstration des folgenden Beispiels werden der Compiler <span class="ckursiv">gcc</span> und der Diassembler <span class="ckursiv">objdump</span> verwendet. Das Funktionieren dieses Beispiels ist nicht auf allen Systemen garantiert, da bei den verschiedenen Betriebssystemen zum Teil unterschiedlich auf den Stack zugegriffen wird.</p>
<p>Folgendes Listing sei gegeben:</p>
<div class="listing"><pre class="prettyprint">/* bufferoverflow2.c */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

void overflow(void) {
   char zeichen[5];
   strcpy(zeichen, "1234567"); /*Überlauf*/
}

int main(void) {
   printf("Mein 1.Buffer Overflow\n");
   overflow();
   return EXIT_SUCCESS;
}</pre></div>
<p>Übersetzen Sie das Programm, und verwenden Sie anschließend den Diassembler, um sich den Maschinencode und den Assembler-Code des Programms anzusehen. Hierfür wird der Diassembler <span class="ckursiv">objdump</span> verwendet, der auf fast jedem System vorhanden sein dürfte. Rufen Sie den Diassembler mit folgender Option in der Kommandozeile auf:</p>
<div class="listing"><pre class="prettyprint">objdump -d bufferoverflow2</pre></div>
<p>Jetzt sollte in etwa folgende Ausgabe auf dem Bildschirm erscheinen (gekürzt):</p>
<div class="listing"><pre class="prettyprint">...
08048490 &lt;overflow&gt;:
 8048490:        55               push   %ebp
 8048491:        89 e5            mov    %esp,%ebp
 8048493:        83 ec 18         sub    $0x18,%esp
 8048496:        83 ec 08         sub    $0x8,%esp
 8048499:        68 44 85 04 08   push   $0x8048544
 804849e:        8d 45 e8         lea    0xffffffe8(%ebp),%eax
 80484a1:        50               push   %eax
 80484a2:        e8 d9 fe ff ff   call   8048380 &lt;_init+0x78&gt;
 80484a7:        83 c4 10         add    $0x10,%esp
 80484aa:        89 ec            mov    %ebp,%esp
 80484ac:        5d               pop    %ebp
 80484ad:        c3               ret
 80484ae:        89 f6            mov    %esi,%esi
...</pre></div>
<p>In der linken Spalte befindet sich der Adressspeicher. An der Adresse »08048490« fängt in diesem Beispiel die Funktion <span class="clisting">overflow()</span> an. Diese Adresse wurde zuvor etwa von der <span class="clisting">main()</span>-Funktion mit</p>
<div class="listing"><pre class="prettyprint">80484c6:        e8 c5 ff ff ff  call   8048490 &lt;overflow&gt;</pre></div>
<p>aufgerufen. In der zweiten Spalte befindet sich der Maschinencode (Opcode). Dieser Code ist schwer für den Menschen nachvollziehbar. Aber alle Zahlen haben ihre Bedeutung. So steht z. B. die Zahl »55« für <span class="clisting">push %ebp</span>, was den Basis-Pointer auf dem Stack sichert, und »5d« entfernt den Basis-Pointer wieder vom Stack. »c3« bedeutet <span class="clisting">ret</span>, also <span class="clisting">return</span>. Mit »c3« wird also wieder an die Rücksprungadresse gesprungen, die in der <span class="clisting">main()</span>-Funktion ebenfalls auf den Stack gepusht wurde. Häufig finden Sie den Maschinencode »90« (<span class="clisting">nop</span>), der nichts anderes macht, als Zeit des Prozessors zu vertrödeln. In der dritten Spalte befindet sich der Assembler-Code, beispielsweise:</p>
<div class="listing"><pre class="prettyprint">add $0x10,%esp
mov %ebp,%esp</pre></div>
<p>Es ist wichtig, dass Sie verstehen, woraus ein Programm eigentlich besteht. Ein einfaches C-Konstrukt wie die <span class="clisting">for</span>-Schleife wird z. B. in Hunderte kleine Maschinencodes (Opcodes) zerlegt. Vielleicht wissen Sie nun, wenn Sie das nächste Mal mit einem Hexeditor ein Programm öffnen, ein bisschen mehr darüber, was diese Zahlen (Maschinencode) und Zeilen (Adressen) bedeuten.</p>
<p>Um es gleich vorwegzunehmen: Dies hier wird kein Assembler-Kurs oder Ähnliches. Das Thema ist recht komplex.</p>
<p>Übersetzen Sie das Programm von eben nochmals mit:</p>
<div class="listing"><pre class="prettyprint">gcc -S -o bufferoverflow2.s bufferoverflow2.c</pre></div>
<p>Jetzt befindet sich im Verzeichnis eine Assembler-Datei (<span class="ckursiv">*.s</span> oder <span class="ckursiv">*.asm</span>) des Programms. Wir wollen uns diese in gekürzter Fassung ansehen:</p>
<div class="listing"><pre class="prettyprint">main:
pushl %ebp       ;Framepointer auf dem Stack
movl  %esp, %ebp ;Stackpointer(esp) in Framepointer(ebp) kopieren
subl  $8, %esp   ;Stackpointer um 8 Bytes verringern
subl  $12, %esp  ;Stackpointer um 12 Bytes verringern für ausgabe printf
pushl $.LC1      ;Den String "Mein 1.Buffer Overflow\n"
call  printf     ;Funktion printf aufrufen
addl  $16, %esp  ;Stackpointer um 16 Bytes erhoehen
call  overflow   ;overflow aufrufen, Rücksprungadresse auf dem
                 ;Stack
movl  $0, %eax
movl  %ebp, %esp
popl  %ebp
ret

overflow:
pushl  %ebp            ;Wieder ein Framepointer auf dem Stack
movl   %esp, %ebp      ;Stackpointer(esp) in Framepointer(ebp)
                       ;kopieren
subl   $24, %esp       ;Stackpointer-24Bytes
subl   $8, %esp        ;Stackpointer-8Bytes
pushl  $.LC0           ;Den String "1234567" auf dem Stack
leal   -24(%ebp), %eax ;Laden des Offsets zu eax
pushl  %eax            ;eax auf dem Stack
call   strcpy          ;Funktion strcpy aufrufen
addl   $16, %esp       ;16 Bytes vom Stack freigeben
movl   %ebp, %esp      ;Stackpointer in Framepointer kopieren
popl   %ebp            ;Framepointer wieder vom Stack
ret                    ;Zurueck zur main-Funktion</pre></div>
<p>Dies ist ein kleiner Überblick über die Assembler-Schreibweise des Programms. Hier ist ja nur die Rücksprungadresse des Aufrufs <span class="clisting">call overflow</span> von Interesse.</p>
<p>Da Sie jetzt wissen, wie Sie an die Rücksprungadresse eines Programms herankommen, können Sie nun ein Programm schreiben, bei dem der Buffer-Overflow, der ja hier durch die Funktion <span class="clisting">strcpy()</span> ausgelöst wird, zum Ändern der Rücksprungadresse genutzt wird. Es wird dabei im Fachjargon von <span class="ckursiv">Buffer-Overflow Exploit</span> gesprochen. Bei dem folgenden Beispiel soll die Rücksprungadresse manipuliert werden:</p>
<div class="listing"><pre class="prettyprint">/* bufferoverflow3.c */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

void funktion(int temp,char *array) {
   char puffer[5];

   strcpy(puffer, array);
   printf("%s\n",puffer);
}

int main(void) {
   int wert;

   wert=0;
   funktion(7,"hallo");
   wert=1;
   printf("%d\n",wert);
}</pre></div>
<p>Das Ziel soll es nun sein, die Funktion <span class="clisting">funktion()</span> aufzurufen und die Rücksprungadresse zu <span class="clisting">wert=1;</span> zu überspringen, sodass <span class="clisting">printf()</span> als Wert 0 anstatt 1 ausgibt. Nach dem Funktionsaufruf sieht der Stack so aus:</p>
<div class="bildbox">
<p><a name="IDACYUQ"></a><a onClick="OpenWin('bilder/27_003.gif','Abbildung',800,800)"><img border="0" src="bilderklein/klein27_003.gif" alt="Abbildung"><br><span class="tabunter">Hier klicken, um das Bild zu vergrößern</span></a></p>
</div>
<p class="tabunter"><strong>Abbildung 27.3    </strong>Der aktuelle Zustand des Stacks</p>
<p>Wie kommen Sie nun am einfachsten zur Rücksprungadresse? Mit einem Zeiger. Also benötigen Sie zuerst einen Zeiger, der auf diese Rücksprungadresse verweist. Anschließend manipulieren Sie die Adresse der Rücksprungadresse, auf die der Pointer zeigt, und zwar so, dass die Wertzuweisung <span class="clisting">wert=1</span> übersprungen wird:</p>
<div class="listing"><pre class="prettyprint">/* bufferoverflow4.c */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

void funktion(int tmp,char *array) {
   char puffer[5];
   int *pointer;

   strcpy(puffer, array);
   printf("%s\n",puffer);
   /* Pointer auf dem Stack um 4 Bytes zurücksetzen.
      Sollte jetzt auf die Rücksprungadresse zeigen. */
   pointer=&amp;tmp-1;
   /*Rücksprungadresse, auf die Pointer zeigt, 10 Bytes weiter*/
   *pointer=*pointer+10;
}

int main(void) {
   int a;

   a=0;
   funktion(7,"hallo");
   a=1;
   printf("wert = %d\n",a);
   return EXIT_SUCCESS;
}</pre></div>
<p>Die einfachste Möglichkeit, auf die Rücksprungadresse zurückzugreifen, besteht darin, um die Speichergröße der Variablen <span class="clisting">temp</span> in der Funktion rückwärts zu springen.</p>
<div class="listing"><pre class="prettyprint">pointer=&amp;tmp-1;</pre></div>
<p>Jetzt können Sie die Rücksprungadresse manipulieren, auf die der <span class="clisting">pointer</span> zeigt:</p>
<div class="listing"><pre class="prettyprint">*pointer=*pointer+10;</pre></div>
<div class="bildbox">
<p><a name="IDAG0UQ"></a><a onClick="OpenWin('bilder/27_004.gif','Abbildung',800,800)"><img border="0" src="bilderklein/klein27_004.gif" alt="Abbildung"><br><span class="tabunter">Hier klicken, um das Bild zu vergrößern</span></a></p>
</div>
<p class="tabunter"><strong>Abbildung 27.4    </strong>Der Zeiger verweist auf die Rücksprungadresse.</p>
<p>Warum habe ich hier die Rücksprungadresse um 10 Bytes erhöht? Dazu müssen Sie wieder <span class="clisting">objdump</span> einsetzen (ohne Opcodes im Beispiel):</p>
<div class="listing"><pre class="prettyprint">objdump -d bufferoverflow4
080484e0 &lt;main&gt;:
...
 80484f7:   call   8048490 &lt;funktion&gt;    ;Aufruf funktion
 80484fc:   add    $0x10,%esp            ;Stack wieder freigeben<span class="cfett">
 80484ff:</span>  <span class="cfett"> movl</span>  <span class="cfett"> $0x1,0xfffffffc(%ebp) ;wert=1</span>
 8048506:   sub    $0x8,%esp<span class="cfett">
 8048509:</span>  <span class="cfett"> pushl</span> <span class="cfett"> 0xfffffffc(%ebp)</span>     <span class="cfett"> ;printf vorbereiten</span>
 804850c:   push   $0x804859e
 8048511:   call   8048360 &lt;_init+0x58&gt;  ;printf aufrufen
...</pre></div>
<p>Die zu überspringende Adresse liegt in diesem Fall ja zwischen »80484ff« und »8048509«. Somit ergibt sich folgende Rechnung:</p>
<div class="listing"><pre class="prettyprint">8048509 - 80484ff = A</pre></div>
<p><span class="clisting">A</span> ist der hexdezimale Wert für 10. Hiermit haben Sie die Rücksprungadresse Ihres eigenen Programms manipuliert. Das Ziel dieser Manipulation ist es aber selten (wie hier dargestellt), die Rücksprungadresse zu ändern, um den Programmcode an einer beliebigen Stelle weiter auszuführen, sondern meistens wird dabei die CPU mit einem eigenen Maschinencode gefüttert. Dabei wird der Maschinencode in einer Variablen auf dem Stack geschrieben und die Rücksprungadresse auf die Startadresse eines fremden Programmcodes gesetzt. Hat der fremde Maschinencode keinen Platz in der Variablen, kann auch der Heap verwendet werden.</p>
<p>Beendet sich hierbei die Funktion, wird durch <span class="clisting">RET</span> auf die Rücksprungadresse gesprungen, die Sie bereits manipuliert haben, und der Hacker kann nun bestimmte Codesequenzen ausführen.</p>
<p>Ihnen dies jetzt zu demonstrieren, würde zum einen den Umfang des Kapitels bei Weitem sprengen und vor allem am Thema vorbeigehen. Zum anderen würde dies neben der gründlichen Kenntnis von C auch gute Kenntnisse im Assembler-Bereich (und unter Linux u.  a. auch der Shell-Programmierung) erfordern.</p>
<p>Zusammengefasst lassen sich Buffer Overflows für folgende Manipulationen ausnutzen:</p>
<ul class="gp">
<li>Inhalte von Variablen, die auf dem Stack liegen, können verändert werden. Stellen Sie sich das einmal bei einer Funktion vor, die ein Passwort vom Anwender abfragt.</li>
</ul>
<ul class="gp">
<li>Die Rücksprungadresse wird manipuliert, sodass das Programm an einer beliebigen Stelle im Speicher mit der Maschinencodeausführung fortfährt. Meistens ist dies die Ausführung des vom Angreifer präparierten Codes. Für die Ausführung von fremdem Code werden wiederum die Variablen auf dem Stack, eventuell auch auf dem Heap verwendet.</li>
</ul>
<ul class="gp">
<li>Dasselbe Schema lässt sich auch mit Zeigern auf Funktionen anwenden. Dabei ist theoretisch nicht einmal ein Buffer-Overflow erforderlich, sondern es reicht die Speicheradresse, an der sich diese Funktion befindet. Die Daten, die für die Ausführung von fremdem Code nötig sind, werden vorzugsweise wieder in einer Variablen gespeichert.</li>
</ul><a id="mj58fbb1931bb9659959092772cce0518a" name="mj58fbb1931bb9659959092772cce0518a"></a><a name="t34"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t35"></a><h3 class="t3"><span class="cfett">27.1.4</span><span class="cfett"> Gegenmaßnahmen zum Buffer-Overflow während der Programmerstellung</span>  <a href="#t2t36"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t34"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Steht Ihr Projekt in den Startlöchern, haben Sie Glück. Wenn Sie diesen Abschnitt durchgelesen haben, ist die Gefahr recht gering, dass Sie während der Programmerstellung eine unsichere Funktion implementieren.</p>
<p>Die meisten Buffer Overflows werden mit den Funktionen der Standard-Bibliothek erzeugt. Das Hauptproblem dieser unsicheren Funktionen ist, dass keine Längenüberprüfung der Ein- bzw. Ausgabe vorhanden ist. Daher wird empfohlen, sofern diese Funktionen auf dem System vorhanden sind, alternative Funktionen zu verwenden, die diese Längenüberprüfung durchführen. Falls es in Ihrem Programm auf Performance ankommt, muss jedoch erwähnt werden, dass die Funktionen mit der n-Alternative (etwa <span class="clisting">strcpy</span> -&gt; <span class="clisting">strncpy</span>) langsamer sind als die ohne.</p>
<p>Hierzu folgt ein Überblick zu anfälligen Funktionen und geeigneten Gegenmaßnahmen, die getroffen werden können.</p>
<h4 class="t4"><span class="cfett">Unsicheres Einlesen von Eingabestreams</span></h4><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<caption class="tabunter"><p class="ptabunter"><strong>Tabelle 27.1    </strong>Unsichere Funktion &#8211; »gets()«</p>
</caption>
<tr>
<td class="tabellenkopf"><span class="cfett">Unsichere Funktion</span>
</td>
<td class="tabellenkopf"><span class="cfett">Gegenmaßnahme</span>
</td>
</tr>
<tr>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">gets(puffer);</pre></div>
</td>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">fgets(puffer, MAX_PUFFER, stdin);</pre></div>
</td>
</tr>
<tr>
<td class="tabellentext" colspan="2">
<p>Bemerkung: Auf Linux-Systemen gibt der Compiler bereits eine Warnmeldung aus, wenn die Funktion <span class="clisting">gets()</span> verwendet wird. Mit <span class="clisting">gets()</span> lesen Sie von der Standardeingabe bis zum nächsten ENTER einen String in einen statischen Puffer ein. Als Gegenmaßnahme wird die Funktion <span class="clisting">fgets()</span> empfohlen, da diese nicht mehr als den bzw. das im zweiten Argument angegebenen Wert bzw. Zeichen einliest.</p>
</td>
</tr>
</table><br><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<caption class="tabunter"><p class="ptabunter"><strong>Tabelle 27.2    </strong>Unsichere Funktion &#8211; »scanf()«</p>
</caption>
<tr>
<td class="tabellenkopf"><span class="cfett">Unsichere Funktion</span>
</td>
<td class="tabellenkopf"><span class="cfett">Gegenmaßnahme</span>
</td>
</tr>
<tr>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">scanf("%s",str);</pre></div>
</td>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">scanf("%10s",str);</pre></div>
</td>
</tr>
<tr>
<td class="tabellentext" colspan="2">
<p>Bemerkung: Auch <span class="clisting">scanf()</span> nimmt bei der Eingabe keine Längenprüfung vor. Die Gegenmaßnahme dazu ist recht simpel. Sie verwenden einfach eine Größenbegrenzung bei der Formatangabe (<span class="clisting">%|</span><span class="cfett">SIZE</span><span class="clisting">|s</span>). Selbiges gilt natürlich auch für <span class="clisting">fscanf()</span>.</p>
</td>
</tr>
</table><br><h4 class="t4"><span class="cfett">Unsichere Funktionen zur Stringbearbeitung</span></h4><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<caption class="tabunter"><p class="ptabunter"><strong>Tabelle 27.3    </strong>Unsichere Funktion &#8211; »strcpy()«</p>
</caption>
<tr>
<td class="tabellenkopf"><span class="cfett">Unsichere Funktion</span>
</td>
<td class="tabellenkopf"><span class="cfett">Gegenmaßnahme</span>
</td>
</tr>
<tr>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">strcpy(buf1, buf2);</pre></div>
</td>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">strncpy(buf1, buf2, SIZE);</pre></div>
</td>
</tr>
<tr>
<td class="tabellentext" colspan="2">
<p>Bemerkung: Bei <span class="clisting">strcpy()</span> wird nicht auf die Größe des Zielpuffers geachtet, mit <span class="clisting">strncpy()</span> hingegen schon. Trotzdem kann mit <span class="clisting">strncpy()</span> bei falscher Verwendung ebenfalls ein Buffer-Overflow ausgelöst werden:</p>
<div class="listing"><pre class="prettyprint">char buf1[100]=&#8217;\0&#8217;;
char buf2[50];

fgets(buf1, 100, stdin);
/* buf2 hat nur Platz für 50 Zeichen */
strncpy(buf2, buf1, sizeof(buf1));</pre></div>
</td>
</tr>
</table><br><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<caption class="tabunter"><p class="ptabunter"><strong>Tabelle 27.4    </strong>Unsichere Funktion &#8211; »strcat()«</p>
</caption>
<tr>
<td class="tabellenkopf"><span class="cfett">Unsichere Funktion</span>
</td>
<td class="tabellenkopf"><span class="cfett">Gegenmaßnahme</span>
</td>
</tr>
<tr>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">strcat(buf1 , buf2);</pre></div>
</td>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">strncat(buf1, buf2, SIZE);</pre></div>
</td>
</tr>
<tr>
<td class="tabellentext" colspan="2">
<p>Bemerkung: Bei <span class="clisting">strcat()</span> wird nicht auf die Größe des Zielpuffers geachtet, mit <span class="clisting">strncat()</span> hingegen schon. Trotzdem kann mit <span class="clisting">strncat()</span> bei falscher Verwendung wie schon bei <span class="clisting">strncpy()</span> ein Buffer-Overflow ausgelöst werden.</p>
</td>
</tr>
</table><br><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<caption class="tabunter"><p class="ptabunter"><strong>Tabelle 27.5    </strong>Unsichere Funktion &#8211; »sprintf()«</p>
</caption>
<tr>
<td class="tabellenkopf"><span class="cfett">Unsichere Funktion</span>
</td>
<td class="tabellenkopf"><span class="cfett">Gegenmaßnahme</span>
</td>
</tr>
<tr>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">sprintf(buf, "%s", temp);</pre></div>
</td>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">snprintf(buf, 100, "%s", temp);</pre></div>
</td>
</tr>
<tr>
<td class="tabellentext" colspan="2">
<p>Bemerkung: Mit <span class="clisting">sprintf()</span> ist es nicht möglich, die Größe des Zielpuffers anzugeben, daher empfiehlt sich auch hier die n-Variante <span class="clisting">snprintf()</span>. Gleiches gilt übrigens auch für die Funktion <span class="clisting">vsprintf()</span>. Auch hier können Sie sich zwischen der Größenbegrenzung und <span class="clisting">vsnprintf()</span> entscheiden.</p>
</td>
</tr>
</table><br><h4 class="t4"><span class="cfett">Unsichere Funktionen zur Bildschirmausgabe</span></h4><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<caption class="tabunter"><p class="ptabunter"><strong>Tabelle 27.6    </strong>Unsichere Funktion &#8211; »printf()«</p>
</caption>
<tr>
<td class="tabellenkopf"><span class="cfett">Unsichere Funktion</span>
</td>
<td class="tabellenkopf"><span class="cfett">Gegenmaßnahme</span>
</td>
</tr>
<tr>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">printf("%s", argv[1]);</pre></div>
</td>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">printf("%100s",argv[1]);</pre></div>
</td>
</tr>
<tr>
<td class="tabellentext" colspan="2">
<p>Bemerkung: Die Länge der Ausgabe von <span class="clisting">printf()</span> ist nicht unbegrenzt. Auch hier würde sich eine Größenbegrenzung gut eignen. Gleiches gilt auch für <span class="clisting">fprintf()</span>.</p>
</td>
</tr>
</table><br><h4 class="t4"><span class="cfett">Weitere unsichere Funktionen im Überblick</span></h4><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<caption class="tabunter"><p class="ptabunter"><strong>Tabelle 27.7    </strong>Unsichere Funktionen &#8211; »getenv()« und »system()«</p>
</caption>
<tr>
<td class="tabellenkopf"><span class="cfett">Unsichere Funktion</span>
</td>
<td class="tabellenkopf"><span class="cfett">Bemerkung</span>
</td>
</tr>
<tr>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">getenv()</pre></div>
</td>
<td class="tabellentext">
<p>Diese Funktion lässt sich ebenfalls für einen Buffer-Overflow verwenden.</p>
</td>
</tr>
<tr>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">system()</pre></div>
</td>
<td class="tabellentext">
<p>Diese Funktion sollte möglichst vermieden werden &#8211; insbesondere dann, wenn der Anwender den String selbst festlegen darf.</p>
</td>
</tr>
</table><br><p>Abhängig von Betriebssystem und Compiler gibt es noch eine Menge mehr solcher unsicherer Funktionen. Die wichtigsten wurden aber hier erwähnt.</p>
<p>Generell sollte man immer alle <span class="clisting">printf()</span>- und <span class="clisting">scanf()</span>-Funktionen mit Vorsicht und Bedacht verwenden. Häufig lässt es sich hier beispielsweise wesentlich sicherer mit <span class="clisting">fwrite()</span> oder <span class="clisting">fread()</span> arbeiten, und die Konversion kann man dabei auch selbst machen. Wenigstens sollte man aber ein Frame um die »unsichereren« Funktionen bauen, die entsprechende Längenüberprüfungen durchführen, wie beispielsweise folgendes Listing zeigen soll:</p>
<div class="listing"><pre class="prettyprint">/* check_before_sprintf.c */
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#define MAX 10

void check_bevore_sprintf(char *quelle, int max) {
   if(strlen(quelle) &lt; MAX)
      return;
   else
      abort(); /* abort zum Debugger */
}

int main(void) {
   char *ptr1 = "123456789";
   char *ptr2 = "1234567890";
   char string[MAX];

   check_bevore_sprintf(ptr1, MAX);
   sprintf(string, "%s", ptr1);
   printf("string: %s\n", string);

   /* Boom!!! */
   check_bevore_sprintf(ptr2, MAX);
   sprintf(string, "%s", ptr2);
   printf("string: %s\n", string);

   return EXIT_SUCCESS;
}</pre></div>
<p>Einige Programmierer gehen sogar so weit, dass sie alle <span class="clisting">printf</span>- und <span class="clisting">scanf</span>-Funktionen aus ihren fertigen Programmen verbannen. Diese Entwickler scheuen auch nicht die Arbeit, hierzu eigene Funktionen (bzw. eine Bibliothek) zu schreiben, die die Benutzereingaben oder Eingabedatei scannen.</p><a id="mj56e75077fd95adcf4f7658306721ac8d" name="mj56e75077fd95adcf4f7658306721ac8d"></a><a name="t35"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t36"></a><h3 class="t3"><span class="cfett">27.1.5</span><span class="cfett"> Gegenmaßnahmen zum Buffer-Overflow, wenn das Programm fertig ist</span>  <a href="#t2t37"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t35"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Wenn das Programm bereits fertig ist, und Sie es noch nicht der Öffentlichkeit zugänglich gemacht haben, können Sie sich die Suchen-Funktion des Compilers zunutze machen oder eine eigene Funktion schreiben. Im Folgenden sehen Sie einen solchen Ansatz. Das Listing gibt alle gefährlichen Funktionen, die in der Stringtabelle <span class="clisting">danger</span> eingetragen sind, auf dem Bildschirm aus.</p>
<div class="listing"><pre class="prettyprint">/* danger.c */
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#define MAX 255

char *danger[] = {
   "scanf", "sscanf", "fscanf",
   "gets", "strcat", "strcpy",
   "printf", "fprintf", "sprintf",
   "vsprintf", "system", NULL
   /* usw. */
};

int main(int argc, char **argv) {
   FILE *fp;
   char puffer[MAX];
   int i, line=1;

   if(argc &lt; 2) {
      printf("Anwendung: %s &lt;datei.c&gt;\n\n", argv[0]);
      return EXIT_FAILURE;
   }
   if ( (fp=fopen(argv[1], "r+")) == NULL) {
      printf("Konnte Datei nicht zum Lesen oeffnen\n");
      return EXIT_FAILURE;
   }
   while( (fgets(puffer, MAX, fp)) != NULL) {
      i=0;
      while(danger[i] != NULL) {
         if( (strstr(puffer,danger[i])) !=0 )
            printf("%s gefunden in Zeile %d\n",
               danger[i],line);
         i++;
      }
      line++;
   }
   fclose(fp);
   return EXIT_SUCCESS;
}</pre></div>
<p>Eine weitere Möglichkeit ist es, eine sogenannte Wrapper-Funktion zu schreiben. Eine Wrapper-Funktion können Sie sich als Strumpf vorstellen, den Sie einer anfälligen Funktion überziehen. Als Beispiel dient hier die Funktion <span class="clisting">gets()</span>:</p>
<div class="listing"><pre class="prettyprint">/* wrap_gets.c */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#define MAX  10
/* Damit es keine Kollision mit gets aus stdio.h gibt. */
#define gets(c) Gets(c)

void Gets(char *z) {
   int ch;
   int counter=0;

   while((ch=getchar()) != '\n') {
      z[counter++]=ch;
      if(counter &gt;= MAX)
         break;
   }
   z[counter] = '\0';     /* Terminieren */
}

int main(int argc, char **argv) {
   char puffer[MAX];

   printf("Eingabe : ");
   gets(puffer);
   printf("puffer = %s\n",puffer);
   return EXIT_SUCCESS;
}</pre></div>
<p>Zuerst musste vor dem Compiler-Lauf die Funktion <span class="clisting">gets()</span> mit</p>
<div class="listing"><pre class="prettyprint">#define gets(c) Gets(c)</pre></div>
<p>ausgeschaltet werden. Jetzt kann statt der echten <span class="clisting">gets()</span>-Version die Wrapper-Funktion <span class="clisting">Gets()</span> verwendet werden. Genauso kann dies bei den anderen gefährlichen Funktionen gemacht werden &#8211; beispielsweise mit der Funktion <span class="clisting">strcpy()</span>:</p>
<div class="listing"><pre class="prettyprint">/* wrap_strcpy.c */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#define MAX  10
 /* Damit es keine Kollision mit strcpy in string.h gibt */
#define strcpy Strcpy
#define DEBUG
/* #undef DEBUG */

void Strcpy(char *ziel, char *quelle) {
   int counter;
#ifdef DEBUG
   /* DEBUG-INFO */
   size_t size = strlen(quelle)+1;
   if( size &gt; MAX )
      printf("DEBUG-INFO: Pufferueberlaufversuch\n");
   /* DEBUG-INFO Ende */
#endif

   for(counter=0; quelle[counter] != '\0' &amp;&amp; counter &lt; MAX-1;
     counter++)
      ziel[counter]=quelle[counter];
   /* terminieren */
   ziel[counter] = '\0';
}

int main(int argc, char **argv) {
   char puffer[MAX];

   strcpy(puffer, "0123456789012345678");
   printf("puffer = %s\n",puffer);
   return EXIT_SUCCESS;
}</pre></div>
<p>Hier wird zum Beispiel noch eine DEBUG-Info mit ausgegeben, falls dies erwünscht ist. Ansonsten muss einfach die Direktive <span class="clisting">undef</span> auskommentiert werden.</p><a id="mj603244ba9ef401163ae95c449f4b9db5" name="mj603244ba9ef401163ae95c449f4b9db5"></a><a name="t36"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t37"></a><h3 class="t3"><span class="cfett">27.1.6</span><span class="cfett"> Programme und Tools zum Buffer-Overflow</span>  <a href="#t2t38"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t36"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Es gibt z. B. auf dem Linux-Sektor zwei gute Bibliotheken, <span class="ckursiv">StackShield</span> und <span class="ckursiv">StackGuard</span>. Beide Bibliotheken arbeiten etwa nach demselben Prinzip. Beim Aufruf einer Funktion greifen diese Bibliotheken ein und sichern die Rücksprungadresse. Dafür wird natürlich ein extra Code am Anfang und Ende des Funktionsaufrufs eingefügt. Wird hierbei versucht, die Rücksprungadresse zu manipulieren, schreibt das Programm eine Warnung in das Syslog des Systems und beendet sich.</p>
<p>Die Voraussetzung dafür, dass Sie eine der beiden Bibliotheken verwenden können, ist, dass Sie im Besitz des Quellcodes des Programms sind, das Sie vor einem Buffer-Overflow schützen wollen. Denn das Programm muss mit den Bibliotheken von StackShield und StackGuard neu übersetzt werden.</p>
<p>Einen anderen Weg geht die Bibliothek <span class="ckursiv">libsafe</span>. Sie entfernt gefährliche Funktionsaufrufe und ersetzt sie durch sichere Versionen. Diese besitzen zusätzlich noch einen Schutz vor dem Überschreiben des Stack-Frames.</p>
<p>Firmen mit einem etwas größeren Geldbeutel sei das Programm <span class="ckursiv">Insure++</span> von Parasoft ans Herz gelegt. Das Programm lässt sich als Testversion einige Zeit kostenlos ausprobieren. Der Anschaffungspreis rechnet sich im Laufe der Zeit allemal. Das Programm ist für alle gängigen Systeme erhältlich und kann außer dem Buffer-Overflow noch eine Menge weiterer Fehler aufdecken. Einige davon sind:</p>
<ul class="gp">
<li>Speicherfehler</li>
</ul>
<ul class="gp">
<li>Speicherlecks</li>
</ul>
<ul class="gp">
<li>Speicherreservierungsfehler</li>
</ul>
<ul class="gp">
<li>Verwendung uninitialisierter Variablen</li>
</ul>
<ul class="gp">
<li>falsche Variablendefinitionen</li>
</ul>
<ul class="gp">
<li>Zeigerfehler</li>
</ul>
<ul class="gp">
<li>Bibliothekenfehler</li>
</ul>
<ul class="gp">
<li>logische Fehler</li>
</ul><a id="mjf7021bcbac0f028124b849400da09938" name="mjf7021bcbac0f028124b849400da09938"></a><a name="t37"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t38"></a><h3 class="t3"><span class="cfett">27.1.7</span><span class="cfett"> Ausblick</span>  <img src="common/15x15leer.gif" width="15" height="15" border="0" alt="top"><a href="#t2t37"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Buffer Overflows werden wohl in Zukunft noch vielen Programmierern Probleme bereiten und noch länger eines der häufigsten Angriffsziele von Hackern darstellen. Daher lohnt es, sich mit diesem Thema zu befassen.</p>
<p>Es wird wohl noch eine Generation dauern, bis Betriebssysteme auf den Markt kommen, die solche Probleme von selbst erkennen und ausgrenzen. Erste Ansätze dazu gibt es zwar schon (Solaris), aber clevere Programmierer haben bereits einen Weg gefunden, auch diese auszuhebeln.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellenkopf"><span class="cfett">Hinweis</span>
</td>
</tr>
<tr>
<td class="tabellentext">
<p class="BStandard">Um es richtigzustellen: Der <span class="ckursiv">Hacker</span> findet Fehler in einem System heraus und meldet diese dem Hersteller des Programms. Entgegen der in den Medien verbreiteten Meinung ist ein Hacker kein Bösewicht. Die Bösewichte werden <span class="ckursiv">Cracker</span> genannt.</p>
</td>
</tr>
</table><br><br><hr><a name="kommentar"></a><h3>Ihr Kommentar</h3>
                       Wie hat Ihnen das &lt;openbook&gt; gefallen? Wir freuen uns immer über Ihre freundlichen und kritischen Rückmeldungen.
                       <form action="http://www.galileo-press.de/feedback/openbook" method="post" style="text-align: center; margin-top: 10px;"><input type="hidden" name="openbookurl" value="http://openbook.galileocomputing.de/c_von_a_bis_z/027_c_sicheres_programmieren_001.htm"><input type="hidden" name="buchtitel" value="C von A bis Z"><input type="hidden" name="Kapitel" value="27 Sicheres Programmieren"><table border="0">
<tr>
<td><label for="name">Name</label><br></td>
<td><input type="text" name="name" id="name" size="40"><br></td>
</tr>
<tr>
<td><label for="email">E-Mail</label><br></td>
<td><input type="text" name="email" id="email" size="40"><br></td>
</tr>
<tr>
<td valign="top"><label for="comment">Ihr Kommentar</label><br></td>
<td><textarea name="comment" id="comment" rows="10" cols="40"></textarea><br></td>
</tr>
<tr>
<td>
</td>
<td><input type="submit" value="Kommentar absenden"></td>
</tr>
</table>
</form>
</div></td>
</tr>
</table></td>
</tr>
<tr>
<td width="100%" class="start" colspan="1" height="22" align="center"><table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="25%"><a href="026_c_paralleles_rechnen_004.htm" class="navnav"> &lt;&lt;   zurück</a></td>
<td width="49%"><div align="center"><a class="navnav" href="#">&lt;top&gt;</a></div></td>
<td align="right" width="25%"><div align="right"><a href="027_c_sicheres_programmieren_002.htm" class="navnav">vor   &gt;&gt; </a></div></td>
</tr>
</table></td>
</tr>
</table>
</div></td>
<td width="10" valign="top">&nbsp;&nbsp;</td>
<td width="160" valign="top">
<table border="0" cellpadding="0" cellspacing="0" width="160">
<tr>
<td>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td class="tbl2" height="20" colspan="2">
&nbsp;<a href="http://www.galileocomputing.de/?GPP=opc3" class="nav">
<strong>Zum Katalog</strong></a>
</td>
</tr>
<tr>
<td valign="top" class="tbl2" width="2">
<img src="common/leer.gif" border="0" height="1" width="1"></td>
<td valign="top">
<table cellspacing="3">
<tr>
<td><a href="http://www.galileocomputing.de/2132?GPP=opc3">
<img src="common/9783836214117_s.gif" width="113" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: C von A bis Z" title="Zum Katalog: C von A bis Z">
<br /><br /><strong>&nbsp;C von A bis Z</strong><br /><img src="common/pfeil_rechts5.gif" border="0" alt="">Jetzt&nbsp;bestellen</a><br /><br />
</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td><img src="common/leer.gif" height="2" width="1" border="0" /></td>
</tr>
<tr>
<td>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td class="tbl2" height="20" colspan="2"><a href="#kommentar" class="nav"><strong>&nbsp;Ihre Meinung?</strong></a>
</td>
</tr>
<tr>
<td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td>
<td valign="top">
<table cellspacing="3">
<tr>
<td>Wie hat Ihnen das &lt;openbook&gt; gefallen?<br /><a href="#kommentar"><img src="common/pfeil_rechts5.gif" border="0" alt="">Ihre Meinung</a>
<br /><br /></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td><img src="common/leer.gif" height="2" width="1" border="0" /></td>
</tr>
<tr>
<td>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td class="tbl2" height="20" colspan="2">&nbsp;<a href="http://www.galileocomputing.de/?GPP=opc3" class="nav"><strong>Buchtipps</strong></a></td>
</tr>
<tr> 
<td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
<a href="http://www.galileocomputing.de/2083?GPP=opc3">
<img src="common/9783836213851_s.gif" width="112" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Einstieg in C++" title="Zum Katalog: Einstieg in C++"><br /><br /><br /><br /><br /><br /><br />&nbsp;Einstieg in C++</a><br /><br /></td>
</tr>
<tr>
<td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
<a href="http://www.galileocomputing.de/2156?GPP=opc3">
<img src="common/9783836214292_s.gif" width="113" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: C++ von A bis Z" title="Zum Katalog: C++ von A bis Z"><br /><br /><br /><br /><br /><br /><br />&nbsp;C++ von A bis Z</a><br /><br /></td>
</tr>
<tr>
<td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
<a href="http://www.galileocomputing.de/1299?GPP=opc3">
<img src="common/9783898428392_s.gif" width="113" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: C/C++" title="Zum Katalog: C/C++"><br /><br /><br /><br /><br /><br /><br />&nbsp;C/C++</a><br /><br /></td>
</tr>
<tr>
<td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
<a href="http://www.galileocomputing.de/1712?GPP=opc3">
<img src="common/9783836211574_s.gif" width="113" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Shell-Programmierung" title="Zum Katalog: Shell-Programmierung"><br /><br /><br /><br /><br /><br /><br />&nbsp;Shell-Programmierung</a><br /><br /></td>
</tr>
<tr>
<td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
<a href="http://www.galileocomputing.de/2049?GPP=opc3">
<img src="common/9783836213660_s.gif" width="119" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Linux-UNIX-Programmierung" title="Zum Katalog: Linux-UNIX-Programmierung"><br /><br /><br /><br /><br /><br /><br />&nbsp;Linux-UNIX-<br />&nbsp;Programmierung</a><br /><br /></td>
</tr>
<tr>
<td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
<a href="http://www.galileocomputing.de/2138?GPP=opc3">
<img src="common/9783836214209_s.gif" width="107" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: IT-Handbuch für Fachinformatiker" title="Zum Katalog: IT-Handbuch für Fachinformatiker"><br /><br /><br /><br /><br /><br /><br />&nbsp;IT-Handbuch für <br />&nbsp;Fachinformatiker</a><br /><br /></td>
</tr>
<tr>
<td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
<a href="http://www.galileocomputing.de/2165?GPP=opc3">
<img src="common/9783836214391_s.gif" width="119" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Ubuntu GNU/Linux" title="Zum Katalog: Ubuntu GNU/Linux"><br /><br /><br /><br /><br /><br /><br />&nbsp;Ubuntu GNU/Linux</a><br /><br /></td>
</tr>
<tr>
<td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
<a href="http://www.galileocomputing.de/1628?GPP=opc3">
<img src="common/9783836211161_s.gif" width="117" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Coding for Fun" title="Zum Katalog: Coding for Fun"><br /><br /><br /><br /><br /><br /><br /><br />&nbsp;Coding for Fun&nbsp;</a><br /><br /></td>
</tr>
</table></td>
</tr>
<tr>
<td><img src="common/leer.gif" height="2" width="1" border="0" /></td>
</tr>
<tr>
<td>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td class="tbl2" height="20" colspan="2"><strong>&nbsp;Shopping</strong></td>
</tr>
<tr>
<td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td>
<td valign="top">
<table cellspacing="3">
<tr>
<td><b>Versandkostenfrei</b> bestellen in Deutschland und &Ouml;sterreich<br /><a href="http://www.galileocomputing.de/hilfe/Shop/?GPP=opc3"><img src="common/pfeil_rechts5.gif" border="0" alt="Info">Info</a><br /><br /></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table><br><br><hr width="70%" align="center">
<div align="center">
<p class="standard"><strong>Copyright © Galileo Press 2009</strong><br>
        Für Ihren privaten Gebrauch dürfen Sie die Online-Version natürlich ausdrucken.
        Ansonsten unterliegt das &lt;openbook&gt; denselben Bestimmungen, wie die
        gebundene Ausgabe: Das Werk einschließlich aller seiner Teile ist urheberrechtlich
        geschützt. Alle Rechte vorbehalten einschließlich der Vervielfältigung, Übersetzung,
        Mikroverfilmung sowie Einspeicherung und Verarbeitung in elektronischen Systemen.</p><br><a href="http://www.galileocomputing.de/">[Galileo Computing]</a><br><br>
      Galileo Press, Rheinwerkallee 4, 53227 Bonn, Tel.: 0228.42150.0, Fax 0228.42150.77, <a href="mailto:info@galileo-press.de">info@galileo-press.de</a></div><br><br></body>
</html>
